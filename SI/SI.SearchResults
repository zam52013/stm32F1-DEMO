---- 1 Matches (3226 in 235 files) ----
00index_e.html (f:\stm32f1-demo\librrary\fat32\documents): <li><a href="res/rwtest1.png">Benchmark 1</a> (ATmega1284/20MHz with MMC via USART in SPI, CFC via GPIO)</li>
Ad.c (f:\stm32f1-demo\drivers\ad):创建时间: 2018-1-05 by zam
Ad.c (f:\stm32f1-demo\drivers\ad):创建时间: 2018-1-05 by zam
Ad.c (f:\stm32f1-demo\drivers\ad):            GPIO_InitStructure.GPIO_Pin = AD_IO_CONFIG[i][1] & 0x0000ffff;
Ad.c (f:\stm32f1-demo\drivers\ad):                case 1:
Ad.c (f:\stm32f1-demo\drivers\ad):创建时间: 2018-1-05 by zam
Ad.c (f:\stm32f1-demo\drivers\ad):    ADC_RegularChannelConfig(ADCx, CH, 1, ADC_SampleTime_13Cycles5); //设置指定的通道以及转换周期
Ad.c (f:\stm32f1-demo\drivers\ad):    return (And >> 1);
Ad.h (f:\stm32f1-demo\drivers):#define POARTA  1
Ad.h (f:\stm32f1-demo\drivers):     1                                                  \
Ad.h (f:\stm32f1-demo\drivers):     1                                                  \
Ad.h (f:\stm32f1-demo\drivers):     1                                                  \
App1.c (f:\stm32f1-demo\librrary\fat32\documents\res):    if (fr != FR_OK) return 1;
App3.c (f:\stm32f1-demo\librrary\fat32\documents\res):    tcl = (len + csz - 1) / csz;    /* Total number of clusters required */
App3.c (f:\stm32f1-demo\librrary\fat32\documents\res):            if (cl + 1 < 3) return 0;   /* Hard error? */
App3.c (f:\stm32f1-demo\librrary\fat32\documents\res):            if (cl != ccl + 1 && cl < fp->fs->n_fatent) break;  /* Not contiguous? */
App3.c (f:\stm32f1-demo\librrary\fat32\documents\res):    fp->fs->last_clust = ccl - 1;
App3.c (f:\stm32f1-demo\librrary\fat32\documents\res):    if (fr) return 1;
App3.c (f:\stm32f1-demo\librrary\fat32\documents\res):        return 1;
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):    if (lfsr & 1) {
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        lfsr >>= 1;
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        lfsr >>= 1;
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):    DWORD sz_drv, lba, lba2, sz_eblk, pns = 1;
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        return 1;
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):    for (cc = 1; cc <= ncyc; cc++) {
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        printf("**** Single sector write test 1 ****\n");
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        printf(" disk_write(%u, 0x%X, %lu, 1)", pdrv, (UINT)pbuff, lba);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        dr = disk_write(pdrv, pbuff, lba, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        printf(" disk_read(%u, 0x%X, %lu, 1)", pdrv, (UINT)pbuff, lba);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        dr = disk_read(pdrv, pbuff, lba, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        lba = 1; ns = sz_buff / sz_sect;
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        printf(" disk_write(%u, 0x%X, %lu, 1)", pdrv, (UINT)(pbuff+3), lba);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        dr = disk_write(pdrv, pbuff+3, lba, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        printf(" disk_read(%u, 0x%X, %lu, 1)", pdrv, (UINT)(pbuff+5), lba);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):        dr = disk_read(pdrv, pbuff+5, lba, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            printf(" disk_write(%u, 0x%X, %lu, 1)", pdrv, (UINT)pbuff, lba);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            dr = disk_write(pdrv, pbuff, lba, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            printf(" disk_write(%u, 0x%X, %lu, 1)", pdrv, (UINT)(pbuff+sz_sect), lba2);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            dr = disk_write(pdrv, pbuff+sz_sect, lba2, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            printf(" disk_read(%u, 0x%X, %lu, 1)", pdrv, (UINT)pbuff, lba);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            dr = disk_read(pdrv, pbuff, lba, 1);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            printf(" disk_read(%u, 0x%X, %lu, 1)", pdrv, (UINT)(pbuff+sz_sect), lba2);
App4.c (f:\stm32f1-demo\librrary\fat32\documents\res):            dr = disk_read(pdrv, pbuff+sz_sect, lba2, 1);
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>disk_ioctl (GET_SECTOR_COUNT)<br>disk_ioctl (GET_BLOCK_SIZE)</td><td>FF_USE_MKFS == 1</td></tr>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>disk_ioctl (CTRL_TRIM)</td><td>FF_USE_TRIM == 1</td></tr>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>ff_cre_syncobj<br>ff_del_syncobj<br>ff_req_grant<br>ff_rel_grant</td><td>FF_FS_REENTRANT == 1</td><td rowspan="2">O/S dependent functions.<br>Samples available in ffsystem.c.</td></tr>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<li>File size: Upto 4 GB - 1 on FAT volume and virtually unlimited on exFAT volume.</li>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr class="ral"><td class="cal">Work area<br><small>(FF_FS_TINY == 1)</small></td><td>V*564<br>+ F*40</td><td>V*564<br>+ F*40</td><td>V*564<br>+ F*40</td><td>V*560<br>+ F*34</td><td>V*560<br>+ F*34</td><td>V*560<br>+ F*34</td><td>V*560<br>+ F*34</td><td>V*564<br>+ F*40</td><td>V*564<br>+ F*40</td><td>V*564<br>+ F*40</td><td>V*564<br>+ F*40</td></tr>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):FF_FS_READONLY   0 (R/W) or 1 (R/O)
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):FF_FS_TINY       0 (Default) or 1 (Tiny file object)
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr>                    <td>0</td><td>1</td><td>2</td><td>3</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>FatFs module supports long file name (LFN). The two different file names, short file name (SFN) and LFN, of a file is transparent on the API except for <tt>f_readdir</tt> function. The support for LFN is disabled by default. To enable the LFN, set <tt><a href="config.html#use_lfn">FF_USE_LFN</a></tt> to 1, 2 or 3, and add <tt>ffunicode.c</tt> to the project. The LFN requiers a certain working buffer in addition. The buffer size can be configured by <tt><a href="config.html#max_lfn">FF_MAX_LFN</a></tt> according to the available memory. The length of an LFN will be up to 255 characters, so that the <tt>FF_MAX_LFN</tt> should be set to 255 for all file names. If the size of working buffer is insufficient for the input file name, the file function fails with <tt>FR_INVALID_NAME</tt>. When use any re-entry to the API with LFN is enabled, <tt>FF_USE_LFN</tt> must be set to 2 or 3. In this case, the file function allocates the working buffer on the stack or heap. The working buffer occupies <tt>(FF_MAX_LFN + 1) * 2</tt> bytes and additional <tt>(FF_MAX_LFN + 44) / 15 * 32</tt> bytes when exFAT is enabled.</p>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Figure 1. Sector misaligned read (short)<br>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The file I/O buffer is a sector buffer to read/write a part of data on the sector. The sector buffer is either file private sector buffer on each file object or shared sector buffer in the filesystem object. The buffer configuration option <tt><a href="config.html#fs_tiny">FF_FS_TINY</a></tt> determins which sector buffer is used for the file data transfer. When tiny buffer configuration (1) is selected, data memory consumption is reduced <tt>FF_MAX_SS</tt> bytes each file object. In this case, FatFs module uses only a sector buffer in the filesystem object for file data transfer and FAT/directory access. The disadvantage of the tiny buffer configuration is: the FAT data cached in the sector buffer will be lost by file data transfer and it must be reloaded at every cluster boundary. However it will be suitable for most application from view point of the decent performance and low memory comsumption.</p>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Figure 1 shows that a partial sector, sector misaligned part of the file, is transferred via the file I/O buffer. At long data transfer shown in Figure 2, middle of transfer data that covers one or more sector is transferred to the application buffer directly. Figure 3 shows that the case of entier transfer data is aligned to the sector boundary. In this case, file I/O buffer is not used. On the direct transfer, the maximum extent of sectors are read with <tt>disk_read</tt> function at a time but the multiple sector transfer is divided at cluster boundary even if it is contiguous.</p>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The write throughput of the flash memory media becomes the worst at single sector write transaction. The write throughput increases as the number of sectors per a write transaction as shown in Figure 6. This effect more appers at faster interface speed and the performance ratio often becomes grater than ten. <a href="../res/rwtest2.png">This graph</a> is clearly explaining how fast is multiple block write (W:16K, 32 sectors) than single block write (W:100, 1 sector), and also larger card tends to be slow at single block write. Number of write transactions also affects life time of the flash memory media. When compared at same amount of write data, the single sector write in Figure 6 above wears flash memory media 16 times more than multiple sector write in Figure 6 below. Single sector write is pretty pain for the flash memory media.</p>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When remove a file with <tt>f_unlink</tt> function, the data clusters occupied by the file are marked 'free' on the FAT. But the data sectors containing the file data are not that applied any process, so that the file data left occupies a part of the flash memory array as 'live block'. If the file data can be erased on removing the file, those data blocks will be turned into the free block pool. This may skip internal block erase operation to the data block on next write operation. As the result the write performance might be improved. FatFs can manage this function by setting <tt><a href="config.html#use_trim">FF_USE_TRIM</a></tt> to 1. Note that this is an expectation of internal process of the storage device and not that always effective. Most applications will not need this function. Also <tt>f_unlink</tt> function can take a time when remove a large file.</p>
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):/ 1. Redistributions of source code must retain the above copyright notice,
Appnote.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Therefore FatFs license is one of the BSD-style licenses but there is a significant feature. FatFs is mainly intended for embedded systems. In order to extend the usability for commercial products, the redistributions of FatFs in binary form, such as embedded code, binary library and any forms without source code, does not need to include about FatFs in the documentations. This is equivalent to the 1-clause BSD license. Of course FatFs is compatible with the most of open source software licenses including GNU GPL. When you redistribute the FatFs source code with any changes or create a fork, the license can also be changed to GNU GPL, BSD-style license or any open source software license that not conflict with FatFs license.</p>
Can.c (f:\stm32f1-demo\drivers\can):创建时间: 2018-1-05 by zam
Can.c (f:\stm32f1-demo\drivers\can):    CAN_FilterInitStructure.CAN_FilterNumber = 1;       //过滤器组
Can.c (f:\stm32f1-demo\drivers\can):创建时间: 2018-1-05 by zam
Can.c (f:\stm32f1-demo\drivers\can):    if(i >= 0XFFF)return 1;
Can.c (f:\stm32f1-demo\drivers\can):创建时间: 2018-1-05 by zam
Chdir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_rpath">FF_FS_RPATH</a> &gt;= 1</tt>.</p>
Chdrive.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_rpath">FF_FS_RPATH</a> &gt;= 1</tt> and <tt><a href="config.html#volumes">FF_VOLUMES</a> &gt;= 2</tt>.</p>
Chmod.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 0</tt> and <tt><a href="config.html#use_chmod">FF_USE_CHMOD</a> == 1</tt>.</p>
Closedir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_minimize">FF_FS_MINIMIZE</a> &lt;= 1</tt>.</p>
Common.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_MESSAGE_CRCS {50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 222, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 78, 196, 0, 0, 15, 3, 0, 0, 0, 0, 0, 167, 183, 119, 191, 118, 148, 21, 0, 243, 124, 0, 0, 38, 20, 158, 152, 143, 0, 0, 0, 106, 49, 22, 143, 140, 5, 150, 0, 231, 183, 63, 54, 47, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 93, 138, 108, 32, 185, 84, 34, 174, 124, 237, 4, 76, 128, 56, 116, 134, 237, 203, 250, 87, 203, 220, 25, 226, 46, 29, 223, 85, 6, 229, 203, 1, 195, 109, 168, 181, 47, 72, 131, 127, 0, 103, 154, 178, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 105, 151, 35, 150, 179, 0, 0, 0, 0, 0, 90, 104, 85, 95, 130, 184, 81, 8, 204, 49, 170, 44, 83, 46, 0}
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_AUTOPILOT_RESERVED=1, /* Reserved for future use. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_TYPE_FIXED_WING=1, /* Fixed wing aircraft. | */
Common.h (f:\stm32f1-demo\mavlink\common):   HL_FAILURE_FLAG_GPS=1, /* GPS failure. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_MODE_FLAG_CUSTOM_MODE_ENABLED=1, /* 0b00000001 Reserved for future use. | */
Common.h (f:\stm32f1-demo\mavlink\common):/** @brief These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not. */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE=1, /* Eighth bit: 00000001 | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_GOTO_DO_CONTINUE=1, /* Continue with the next item in mission execution. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_STATE_BOOT=1, /* System is booting up. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_COMP_ID_AUTOPILOT1=1, /*  | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_SYS_STATUS_SENSOR_3D_GYRO=1, /* 0x01 3D gyro | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_FRAME_LOCAL_NED=1, /* Local coordinate frame, Z-down (x: north, y: east, z: down). | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_FRAME_GLOBAL_INT=5, /* Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL). | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAVLINK_DATA_STREAM_IMG_JPEG=1, /*  | */
Common.h (f:\stm32f1-demo\mavlink\common):   FENCE_ACTION_GUIDED=1, /* Switched to guided mode to return point (fence point 0) | */
Common.h (f:\stm32f1-demo\mavlink\common):   FENCE_BREACH_MINALT=1, /* Breached minimum altitude | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_MOUNT_MODE_NEUTRAL=1, /* Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory. | */
Common.h (f:\stm32f1-demo\mavlink\common):   UAVCAN_NODE_HEALTH_WARNING=1, /* A critical parameter went out of range or the node has encountered a minor failure. | */
Common.h (f:\stm32f1-demo\mavlink\common):   UAVCAN_NODE_MODE_INITIALIZATION=1, /* The node is initializing; this mode is entered immediately after startup. | */
Common.h (f:\stm32f1-demo\mavlink\common):/** @brief Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data. */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_LOITER_TURNS=18, /* Loiter around this waypoint for X turns |Turns| Empty| Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise| Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle| Latitude| Longitude| Altitude|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_LOITER_TIME=19, /* Loiter around this waypoint for X seconds |Seconds (decimal)| Empty| Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise| Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle| Latitude| Longitude| Altitude|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_LAND=21, /* Land at location |Abort Alt| Precision land mode. (0 = normal landing, 1 = opportunistic precision landing, 2 = required precsion landing)| Empty| Desired yaw angle. NaN for unchanged.| Latitude| Longitude| Altitude (ground level)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_LAND_LOCAL=23, /* Land at local position (local frame only) |Landing target number (if available)| Maximum accepted offset from desired landing position [m] - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land| Landing descend rate [ms^-1]| Desired yaw angle [rad]| Y-axis position [m]| X-axis position [m]| Z-axis / ground level position [m]|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_TAKEOFF_LOCAL=24, /* Takeoff from local position (local frame only) |Minimum pitch (if airspeed sensor present), desired pitch without sensor [rad]| Empty| Takeoff ascend rate [ms^-1]| Yaw angle [rad] (if magnetometer or another yaw estimation source present), ignored without one of these| Y-axis position [m]| X-axis position [m]| Z-axis position [m]|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT=30, /* Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached. |Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude. | Empty| Empty| Empty| Empty| Empty| Desired altitude in meters|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_LOITER_TO_ALT=31, /* Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.  Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter until heading toward the next waypoint.  |Heading Required (0 = False)| Radius in meters. If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.| Empty| Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location| Latitude| Longitude| Altitude|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_FOLLOW=32, /* Being following a target |System ID (the system ID of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode| RESERVED| RESERVED| altitude flag: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home| altitude| RESERVED| TTL in seconds in which the MAV should go to the default position hold mode after a message rx timeout|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_PATHPLANNING=81, /* Control autonomous path planning on the MAV. |0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning| 0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid| Empty| Yaw angle at goal, in compass degrees, [0..360]| Latitude/X of goal| Longitude/Y of goal| Altitude/Z of goal|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_DELAY=93, /* Delay the next navigation command a number of seconds or until a specified time |Delay in seconds (decimal, -1 to enable time-of-day fields)| hour (24h format, UTC, -1 to ignore)| minute (24h format, UTC, -1 to ignore)| second (24h format, UTC)| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_CONDITION_YAW=115, /* Reach a certain target angle. |target angle: [0-360], 0 is north| speed during yaw change:[deg per second]| direction: negative: counter clockwise, positive: clockwise [-1,1]| relative offset or absolute angle: [ 1,0]| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_CHANGE_SPEED=178, /* Change speed and/or throttle set points. |Speed type (0=Airspeed, 1=Ground Speed)| Speed  (m/s, -1 indicates no change)| Throttle  ( Percent, -1 indicates no change)| absolute or relative [0,1]| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_SET_HOME=179, /* Changes the home location either to the current location or a specified location. |Use current (1=use current location, 0=use specified location)| Empty| Empty| Empty| Latitude| Longitude| Altitude|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_SET_RELAY=181, /* Set a relay to a condition. |Relay number| Setting (1=on, 0=off, others possible depending on system hardware)| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_REPOSITION=192, /* Reposition the vehicle to a specific WGS84 global position. |Ground speed, less than 0 (-1) for default| Bitmask of option flags, see the MAV_DO_REPOSITION_FLAGS enum.| Reserved| Yaw heading, NaN for unchanged. For planes indicates loiter direction (0: clockwise, 1: counter clockwise)| Latitude (deg * 1E7)| Longitude (deg * 1E7)| Altitude (meters)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_PAUSE_CONTINUE=193, /* If in a GPS controlled position mode, hold the current position or continue. |0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.| Reserved| Reserved| Reserved| Reserved| Reserved| Reserved|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_SET_REVERSE=194, /* Set moving direction to forward or reverse. |Direction (0=Forward, 1=Reverse)| Empty| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_CONTROL_VIDEO=200, /* Control onboard camera system. |Camera ID (-1 for all)| Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw| Transmission mode: 0: video stream, >0: single images every n seconds (decimal)| Recording: 0: disabled, 1: enabled compressed, 2: enabled raw| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_DIGICAM_CONTROL=203, /* THIS INTERFACE IS DEPRECATED since 2018-01. Please use PARAM_EXT_XXX messages and the camera definition format described in https://mavlink.io/en/protocol/camera_def.html. |Session control e.g. show/hide lens| Zoom's absolute position| Zooming step value to offset zoom from the current position| Focus Locking, Unlocking or Re-locking| Shooting Command| Command Identity| Test shot identifier. If set to 1, image will only be captured, but not counted towards internal frame count.|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_MOUNT_CONFIGURE=204, /* Mission command to configure a camera or antenna mount |Mount operation mode (see MAV_MOUNT_MODE enum)| stabilize roll? (1 = yes, 0 = no)| stabilize pitch? (1 = yes, 0 = no)| stabilize yaw? (1 = yes, 0 = no)| roll input (0 = angle, 1 = angular rate)| pitch input (0 = angle, 1 = angular rate)| yaw input (0 = angle, 1 = angular rate)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_SET_CAM_TRIGG_DIST=206, /* Mission command to set camera trigger distance for this flight. The camera is trigerred each time this distance is exceeded. This command can also be used to set the shutter integration time for the camera. |Camera trigger distance (meters). 0 to stop triggering.| Camera shutter integration time (milliseconds). -1 or 0 to ignore| Trigger camera once immediately. (0 = no trigger, 1 = trigger)| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_FENCE_ENABLE=207, /* Mission command to enable the geofence |enable? (0=disable, 1=enable, 2=disable_floor_only)| Empty| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_PARACHUTE=208, /* Mission command to trigger a parachute |action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)| Empty| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_MOTOR_TEST=209, /* Mission command to perform motor test |motor number (a number from 1 to max number of motors on the vehicle)| throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)| throttle| timeout (in seconds)| motor count (number of motors to test to test in sequence, waiting for the timeout above between them; 0=1 motor, 1=1 motor, 2=2 motors...)| motor test order (See MOTOR_TEST_ORDER enum)| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_INVERTED_FLIGHT=210, /* Change to/from inverted flight |inverted (0=normal, 1=inverted)| Empty| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_NAV_SET_YAW_SPEED=213, /* Sets a desired vehicle turn angle and speed change |yaw angle to adjust steering by in centidegress| speed - normalized to 0 .. 1| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL=214, /* Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is triggered each time this interval expires. This command can also be used to set the shutter integration time for the camera. |Camera trigger cycle time (milliseconds). -1 or 0 to ignore.| Camera shutter integration time (milliseconds). Should be less than trigger cycle time. -1 or 0 to ignore.| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_MOUNT_CONTROL_QUAT=220, /* Mission command to control a camera or antenna mount, using a quaternion as reference. |q1 - quaternion param #1, w (1 in null-rotation)| q2 - quaternion param #2, x (0 in null-rotation)| q3 - quaternion param #3, y (0 in null-rotation)| q4 - quaternion param #4, z (0 in null-rotation)| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_ENGINE_CONTROL=223, /* Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine state. It is intended for vehicles with internal combustion engines |0: Stop engine, 1:Start Engine| 0: Warm start, 1:Cold start. Controls use of choke where applicable| Height delay (meters). This is for commanding engine start only after the vehicle has gained the specified height. Used in VTOL vehicles during takeoff to start engine after the aircraft is off the ground. Zero for no delay.| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PREFLIGHT_CALIBRATION=241, /* Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature Calibration, only one sensor should be set in a single message and all others should be zero. |1: gyro calibration, 3: gyro temperature calibration| 1: magnetometer calibration| 1: ground pressure calibration| 1: radio RC calibration, 2: RC trim calibration| 1: accelerometer calibration, 2: board level calibration, 3: accelerometer temperature calibration, 4: simple accelerometer calibration| 1: APM: compass/motor interference calibration (PX4: airspeed calibration, deprecated), 2: airspeed calibration| 1: ESC calibration, 3: barometer temperature calibration|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS=242, /* Set sensor offsets. This command will be only accepted if in pre-flight mode. |Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer, 6: third magnetometer| X axis offset (or generic dimension 1), in the sensor's raw units| Y axis offset (or generic dimension 2), in the sensor's raw units| Z axis offset (or generic dimension 3), in the sensor's raw units| Generic dimension 4, in the sensor's raw units| Generic dimension 5, in the sensor's raw units| Generic dimension 6, in the sensor's raw units|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PREFLIGHT_UAVCAN=243, /* Trigger UAVCAN config. This command will be only accepted if in pre-flight mode. |1: Trigger actuator ID assignment and direction mapping.| Reserved| Reserved| Reserved| Reserved| Reserved| Reserved|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PREFLIGHT_STORAGE=245, /* Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode. |Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults| Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults| Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, > 1: start logging with rate of param 3 in Hz (e.g. set to 1000 for 1000 Hz logging)| Reserved| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN=246, /* Request the reboot or shutdown of system components. |0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.| 0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.| WIP: 0: Do nothing for camera, 1: Reboot onboard camera, 2: Shutdown onboard camera, 3: Reboot onboard camera and keep it in the bootloader until upgraded| WIP: 0: Do nothing for mount (e.g. gimbal), 1: Reboot mount, 2: Shutdown mount, 3: Reboot mount and keep it in the bootloader until upgraded| Reserved, send 0| Reserved, send 0| WIP: ID (e.g. camera ID -1 for all IDs)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_COMPONENT_ARM_DISARM=400, /* Arms / Disarms a component |1 to arm, 0 to disarm|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_SET_MESSAGE_INTERVAL=511, /* Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM |The MAVLink message ID| The interval between two messages, in microseconds. Set to -1 to disable and 0 to request default rate.|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_PROTOCOL_VERSION=519, /* Request MAVLink protocol version compatibility |1: Request supported protocol versions by all nodes on the network| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES=520, /* Request autopilot capabilities |1: Request autopilot version| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_CAMERA_INFORMATION=521, /* Request camera information (CAMERA_INFORMATION). |0: No action 1: Request camera capabilities| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_CAMERA_SETTINGS=522, /* Request camera settings (CAMERA_SETTINGS). |0: No Action 1: Request camera settings| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_STORAGE_INFORMATION=525, /* WIP: Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a specific component's storage. |Storage ID (0 for all, 1 for first, 2 for second, etc.)| 0: No Action 1: Request storage information| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_STORAGE_FORMAT=526, /* WIP: Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the command's target_component to target a specific component's storage. |Storage ID (1 for first, 2 for second, etc.)| 0: No action 1: Format storage| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS=527, /* Request camera capture status (CAMERA_CAPTURE_STATUS) |0: No Action 1: Request camera capture status| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_FLIGHT_INFORMATION=528, /* WIP: Request flight information (FLIGHT_INFORMATION) |1: Request flight information| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_RESET_CAMERA_SETTINGS=529, /* Reset all camera settings to Factory Default |0: No Action 1: Reset all settings| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_IMAGE_START_CAPTURE=2000, /* Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NAN for reserved values. |Reserved (Set to 0)| Duration between two consecutive pictures (in seconds)| Number of images to capture total - 0 for unlimited capture| Capture sequence (ID to prevent double captures when a command is retransmitted, 0: unused, >= 1: used)| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_DO_TRIGGER_CONTROL=2003, /* Enable or disable on-board camera triggering system. |Trigger enable/disable (0 for disable, 1 for start), -1 to ignore| 1 to reset the trigger sequence, -1 or 0 to ignore| 1 to pause triggering, but without switching the camera off or retracting it. -1 to ignore|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_VIDEO_START_STREAMING=2502, /* WIP: Start video streaming |Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)| Reserved|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_VIDEO_STOP_STREAMING=2503, /* WIP: Stop the current video streaming |Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)| Reserved|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION=2504, /* WIP: Request video stream information (VIDEO_STREAM_INFORMATION) |Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)| 0: No Action 1: Request video stream information| Reserved (all remaining params)|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_AIRFRAME_CONFIGURATION=2520, /*  |Landing gear ID (default: 0, -1 for all)| Landing gear position (Down: 0, Up: 1, NAN for no change)| Reserved, set to NAN| Reserved, set to NAN| Reserved, set to NAN| Reserved, set to NAN| Reserved, set to NAN|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_CONTROL_HIGH_LATENCY=2600, /* Request to start/stop transmitting over the high latency telemetry |Control transmittion over high latency telemetry (0: stop, 1: start)| Empty| Empty| Empty| Empty| Empty| Empty|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PAYLOAD_PREPARE_DEPLOY=30001, /* Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity. |Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.| Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.| Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.| Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.| Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT| Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT| Altitude, in meters AMSL|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_PAYLOAD_CONTROL_DEPLOY=30002, /* Control the payload deployment. |Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.| Reserved| Reserved| Reserved| Reserved| Reserved| Reserved|  */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_DATA_STREAM_RAW_SENSORS=1, /* Enable IMU_RAW, GPS_RAW, GPS_STATUS packets. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_ROI_WPNEXT=1, /* Point toward next waypoint, with optional pitch/roll/yaw offset. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_CMD_ACK_OK=1, /* Command / mission item is ok. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_PARAM_TYPE_UINT8=1, /* 8-bit unsigned integer | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_PARAM_EXT_TYPE_UINT8=1, /* 8-bit unsigned integer | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_RESULT_TEMPORARILY_REJECTED=1, /* Command TEMPORARY REJECTED/DENIED | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_MISSION_ERROR=1, /* generic error / not accepting mission commands at all right now | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_SEVERITY_ALERT=1, /* Action should be taken immediately. Indicates error in non-critical systems. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_POWER_STATUS_BRICK_VALID=1, /* main brick power supply valid | */
Common.h (f:\stm32f1-demo\mavlink\common):   SERIAL_CONTROL_DEV_TELEM2=1, /* Second telemetry port | */
Common.h (f:\stm32f1-demo\mavlink\common):   SERIAL_CONTROL_FLAG_REPLY=1, /* Set if this is a reply | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_DISTANCE_SENSOR_ULTRASOUND=1, /* Ultrasound rangefinder, e.g. MaxBotix units | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_SENSOR_ROTATION_YAW_45=1, /* Roll: 0, Pitch: 0, Yaw: 45 | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT=1, /* Autopilot supports MISSION float message type. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_MISSION_TYPE_FENCE=1, /* Specifies GeoFence area(s). Items are MAV_CMD_FENCE_ GeoFence items. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_ESTIMATOR_TYPE_NAIVE=1, /* This is a naive estimator without any real covariance feedback. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_BATTERY_TYPE_LIPO=1, /* Lithium polymer battery | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_BATTERY_FUNCTION_ALL=1, /* Battery supports all flight systems | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_BATTERY_CHARGE_STATE_OK=1, /* Battery is not in low state. Normal operation. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_VTOL_STATE_TRANSITION_TO_FW=1, /* VTOL is in transition from multicopter to fixed-wing | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_LANDED_STATE_ON_GROUND=1, /* MAV is landed (on ground) | */
Common.h (f:\stm32f1-demo\mavlink\common):   ADSB_ALTITUDE_TYPE_GEOMETRIC=1, /* Altitude reported from a GNSS source | */
Common.h (f:\stm32f1-demo\mavlink\common):   ADSB_EMITTER_TYPE_LIGHT=1, /*  | */
Common.h (f:\stm32f1-demo\mavlink\common):   ADSB_FLAGS_VALID_COORDS=1, /*  | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_DO_REPOSITION_FLAGS_CHANGE_MODE=1, /* The aircraft should immediately transition into guided. This should not be set for follow me applications | */
Common.h (f:\stm32f1-demo\mavlink\common):   ESTIMATOR_ATTITUDE=1, /* True if the attitude estimate is good | */
Common.h (f:\stm32f1-demo\mavlink\common):   MOTOR_TEST_ORDER_SEQUENCE=1, /* motor numbers are specified as their index in a predefined vehicle-specific sequence | */
Common.h (f:\stm32f1-demo\mavlink\common):   MOTOR_TEST_THROTTLE_PWM=1, /* throttle as an absolute PWM value (normally in range of 1000~2000) | */
Common.h (f:\stm32f1-demo\mavlink\common):   GPS_INPUT_IGNORE_FLAG_ALT=1, /* ignore altitude field | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_COLLISION_ACTION_REPORT=1, /* Report potential collision | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_COLLISION_THREAT_LEVEL_LOW=1, /* Craft is mildly concerned about this threat | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT=1, /* ID field references MAVLink SRC ID | */
Common.h (f:\stm32f1-demo\mavlink\common):   GPS_FIX_TYPE_NO_FIX=1, /* No position information, GPS is connected | */
Common.h (f:\stm32f1-demo\mavlink\common):   LANDING_TARGET_TYPE_RADIO_BEACON=1, /* Landing target signaled by radio beacon (ex: ILS, NDB) | */
Common.h (f:\stm32f1-demo\mavlink\common):   VTOL_TRANSITION_HEADING_NEXT_WAYPOINT=1, /* Use the heading pointing towards the next waypoint. | */
Common.h (f:\stm32f1-demo\mavlink\common):   CAMERA_CAP_FLAGS_CAPTURE_VIDEO=1, /* Camera is able to record video. | */
Common.h (f:\stm32f1-demo\mavlink\common):   PARAM_ACK_VALUE_UNSUPPORTED=1, /* Parameter value UNKNOWN/UNSUPPORTED | */
Common.h (f:\stm32f1-demo\mavlink\common):   CAMERA_MODE_VIDEO=1, /* Camera is in video capture mode. | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_ARM_AUTH_DENIED_REASON_NONE=1, /* Authorizer will send the error as string to GCS | */
Common.h (f:\stm32f1-demo\mavlink\common):   RTK_BASELINE_COORDINATE_SYSTEM_NED=1, /* North, East, Down | */
Common.h (f:\stm32f1-demo\mavlink\common):   RC_TYPE_SPEKTRUM_DSMX=1, /* Spektrum DSMX | */
Common.h (f:\stm32f1-demo\mavlink\common):   MAV_TRAJECTORY_REPRESENTATION_BEZIER=1, /* WORK IN PROGRESS! DO NOT DEPLOY! Array of bezier points with the following order |X-coordinate of starting bezier point [m], set to NaN if not being used| Y-coordinate of starting bezier point [m], set to NaN if not being used| Z-coordinate of starting bezier point [m], set to NaN if not being used| Bezier time horizon [s], set to NaN if velocity/acceleration should not be incorporated| Yaw [rad], set to NaN for unchanged|  */
Common.h (f:\stm32f1-demo\mavlink\common):# define MAVLINK_MESSAGE_NAMES {{ "ACTUATOR_CONTROL_TARGET", 140 }, { "ADSB_VEHICLE", 246 }, { "ALTITUDE", 141 }, { "ATTITUDE", 30 }, { "ATTITUDE_QUATERNION", 31 }, { "ATTITUDE_QUATERNION_COV", 61 }, { "ATTITUDE_TARGET", 83 }, { "ATT_POS_MOCAP", 138 }, { "AUTH_KEY", 7 }, { "AUTOPILOT_VERSION", 148 }, { "BATTERY_STATUS", 147 }, { "CAMERA_TRIGGER", 112 }, { "CHANGE_OPERATOR_CONTROL", 5 }, { "CHANGE_OPERATOR_CONTROL_ACK", 6 }, { "COLLISION", 247 }, { "COMMAND_ACK", 77 }, { "COMMAND_INT", 75 }, { "COMMAND_LONG", 76 }, { "CONTROL_SYSTEM_STATE", 146 }, { "DATA_STREAM", 67 }, { "DATA_TRANSMISSION_HANDSHAKE", 130 }, { "DEBUG", 254 }, { "DEBUG_VECT", 250 }, { "DISTANCE_SENSOR", 132 }, { "ENCAPSULATED_DATA", 131 }, { "ESTIMATOR_STATUS", 230 }, { "EXTENDED_SYS_STATE", 245 }, { "FILE_TRANSFER_PROTOCOL", 110 }, { "FOLLOW_TARGET", 144 }, { "GLOBAL_POSITION_INT", 33 }, { "GLOBAL_POSITION_INT_COV", 63 }, { "GLOBAL_VISION_POSITION_ESTIMATE", 101 }, { "GPS2_RAW", 124 }, { "GPS2_RTK", 128 }, { "GPS_GLOBAL_ORIGIN", 49 }, { "GPS_INJECT_DATA", 123 }, { "GPS_INPUT", 232 }, { "GPS_RAW_INT", 24 }, { "GPS_RTCM_DATA", 233 }, { "GPS_RTK", 127 }, { "GPS_STATUS", 25 }, { "HEARTBEAT", 0 }, { "HIGHRES_IMU", 105 }, { "HIGH_LATENCY", 234 }, { "HIGH_LATENCY2", 235 }, { "HIL_ACTUATOR_CONTROLS", 93 }, { "HIL_CONTROLS", 91 }, { "HIL_GPS", 113 }, { "HIL_OPTICAL_FLOW", 114 }, { "HIL_RC_INPUTS_RAW", 92 }, { "HIL_SENSOR", 107 }, { "HIL_STATE", 90 }, { "HIL_STATE_QUATERNION", 115 }, { "HOME_POSITION", 242 }, { "LANDING_TARGET", 149 }, { "LOCAL_POSITION_NED", 32 }, { "LOCAL_POSITION_NED_COV", 64 }, { "LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET", 89 }, { "LOG_DATA", 120 }, { "LOG_ENTRY", 118 }, { "LOG_ERASE", 121 }, { "LOG_REQUEST_DATA", 119 }, { "LOG_REQUEST_END", 122 }, { "LOG_REQUEST_LIST", 117 }, { "MANUAL_CONTROL", 69 }, { "MANUAL_SETPOINT", 81 }, { "MEMORY_VECT", 249 }, { "MESSAGE_INTERVAL", 244 }, { "MISSION_ACK", 47 }, { "MISSION_CLEAR_ALL", 45 }, { "MISSION_COUNT", 44 }, { "MISSION_CURRENT", 42 }, { "MISSION_ITEM", 39 }, { "MISSION_ITEM_INT", 73 }, { "MISSION_ITEM_REACHED", 46 }, { "MISSION_REQUEST", 40 }, { "MISSION_REQUEST_INT", 51 }, { "MISSION_REQUEST_LIST", 43 }, { "MISSION_REQUEST_PARTIAL_LIST", 37 }, { "MISSION_SET_CURRENT", 41 }, { "MISSION_WRITE_PARTIAL_LIST", 38 }, { "NAMED_VALUE_FLOAT", 251 }, { "NAMED_VALUE_INT", 252 }, { "NAV_CONTROLLER_OUTPUT", 62 }, { "OPTICAL_FLOW", 100 }, { "OPTICAL_FLOW_RAD", 106 }, { "PARAM_MAP_RC", 50 }, { "PARAM_REQUEST_LIST", 21 }, { "PARAM_REQUEST_READ", 20 }, { "PARAM_SET", 23 }, { "PARAM_VALUE", 22 }, { "PING", 4 }, { "POSITION_TARGET_GLOBAL_INT", 87 }, { "POSITION_TARGET_LOCAL_NED", 85 }, { "POWER_STATUS", 125 }, { "RADIO_STATUS", 109 }, { "RAW_IMU", 27 }, { "RAW_PRESSURE", 28 }, { "RC_CHANNELS", 65 }, { "RC_CHANNELS_OVERRIDE", 70 }, { "RC_CHANNELS_RAW", 35 }, { "RC_CHANNELS_SCALED", 34 }, { "REQUEST_DATA_STREAM", 66 }, { "RESOURCE_REQUEST", 142 }, { "SAFETY_ALLOWED_AREA", 55 }, { "SAFETY_SET_ALLOWED_AREA", 54 }, { "SCALED_IMU", 26 }, { "SCALED_IMU2", 116 }, { "SCALED_IMU3", 129 }, { "SCALED_PRESSURE", 29 }, { "SCALED_PRESSURE2", 137 }, { "SCALED_PRESSURE3", 143 }, { "SERIAL_CONTROL", 126 }, { "SERVO_OUTPUT_RAW", 36 }, { "SET_ACTUATOR_CONTROL_TARGET", 139 }, { "SET_ATTITUDE_TARGET", 82 }, { "SET_GPS_GLOBAL_ORIGIN", 48 }, { "SET_HOME_POSITION", 243 }, { "SET_MODE", 11 }, { "SET_POSITION_TARGET_GLOBAL_INT", 86 }, { "SET_POSITION_TARGET_LOCAL_NED", 84 }, { "SIM_STATE", 108 }, { "STATUSTEXT", 253 }, { "SYSTEM_TIME", 2 }, { "SYS_STATUS", 1 }, { "TERRAIN_CHECK", 135 }, { "TERRAIN_DATA", 134 }, { "TERRAIN_REPORT", 136 }, { "TERRAIN_REQUEST", 133 }, { "TIMESYNC", 111 }, { "V2_EXTENSION", 248 }, { "VFR_HUD", 74 }, { "VIBRATION", 241 }, { "VICON_POSITION_ESTIMATE", 104 }, { "VISION_POSITION_ESTIMATE", 102 }, { "VISION_SPEED_ESTIMATE", 103 }, { "WIND_COV", 231 }}
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Read/Write (0) or Read-only (1). Read-only configuration removes writing API functions, <tt>f_write</tt>, <tt>f_sync</tt>, <tt>f_unlink</tt>, <tt>f_mkdir</tt>, <tt>f_chmod</tt>, <tt>f_rename</tt>, <tt>f_truncate</tt>, <tt>f_getfree</tt> and optional writing functions as well.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>1</td><td><tt>f_stat</tt>, <tt>f_getfree</tt>, <tt>f_unlink</tt>, <tt>f_mkdir</tt>, <tt>f_chmod</tt>, <tt>f_utime</tt>, <tt>f_truncate</tt> and <tt>f_rename</tt> function are removed.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>2</td><td><tt>f_opendir</tt>, <tt>f_readdir</tt> and <tt>f_closedir</tt> function are removed in addition to 1.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>1</td><td>Enable string functions without LF-CRLF conversion.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) filtered directory read functions, <tt>f_findfirst</tt> and <tt>f_findnext</tt>. Also <tt>FF_FS_MINIMIZE</tt> needs to be 0 or 1.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) <tt>f_mkfs</tt> function.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) fast seek function to enable accelerated mode for <tt>f_lseek</tt>, <tt>f_read</tt> and <tt>f_write</tt> function. For more information, read <a href="lseek.html">here</a>.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) <tt>f_expand</tt> function.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) metadata control functions, <tt>f_chmod</tt> and <tt>f_utime</tt>. Also <tt>FF_FS_READONLY</tt> needs to be 0.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) API functions for volume label, <tt>f_getlabel</tt> and <tt>f_setlabel</tt>.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1) <tt>f_forward</tt> function.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>850</td><td>Latin 1</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>1</td><td>Enable LFN with static working buffer on the BSS. Always NOT thread-safe.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>LFN function requiers certain internal working buffer for the file name. This option defines size of the buffer and the value can be in range of 12 to 255 in UTF-16 encoding unit of the LFN. The buffer occupies <tt>(FF_MAX_LFN + 1) * 2</tt> bytes and additional <tt>(FF_MAX_LFN + 44) / 15 * 32</tt> bytes when exFAT is enabled. It is recommended to be set 255 to fully support the LFN specification. This option has no effect when LFN is not enabled.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>1</td><td>Unicode in UTF-16</td><td>WCHAR</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When character encoding on the API is Unicode (<tt>FF_LFN_UNICODE &gt;= 1</tt>), string I/O functions, <tt>f_gets</tt>, <tt>f_putc</tt>, <tt>f_puts</tt> and <tt>f_printf</tt>, convert the character encodins in it. This option defines the assumption of character encoding <em>on the file</em> to be read/written via those functions. When LFN is not enabled or <tt>FF_LFN_UNICODE == 0</tt>, the string functions work without any code conversion and this option has no effect.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>1</td><td>Unicode in UTF-16LE</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>1</td><td>Enable relative path function. <tt>f_chdir</tt> and <tt>f_chdrive</tt> function is available.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>2</td><td><tt>f_getcwd</tt> function is available in addition to 1</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This option configures number of volumes (logical drives, from 1 to 10) to be used.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1). This option switches the support for string volume ID. When enabled, also pre-defined strings in <tt>FF_VOLUME_STRS</tt> can be used as drive identifier in the path name.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1). This option switches multi-partition function. By default (0), each logical drive number is bound to the same physical drive number and only a volume in the physical drive is mounted. When enabled, each logical drive is bound to the partition on the physical drive listed in the user defined partition resolution table <tt>VolToPart[]</tt>. Also <tt>f_fdisk</tt> funciton will be available. For more information, read <a href="filename.html#vol">here</a>.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1). This option switches ATA-TRIM function. To enable Trim function, also <tt>CTRL_TRIM</tt> command should be implemented to the <tt>disk_ioctl</tt> function.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>0 to 3. If you need to know correct free space on the FAT32 volume, set bit 0 of this option, and <tt>f_getfree</tt> function at first time after volume mount will force a full FAT scan. Bit 1 controls the use of last allocated cluster number.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>bit0=1</td><td>Do not trust free cluster count in the FSINFO.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>bit1=1</td><td>Do not trust last allocated cluster number in the FSINFO.</td></tr>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Normal (0) or Tiny (1). At the tiny configuration, size of the file object <tt>FIL</tt> is reduced <tt>FF_MAX_SS</tt> bytes. Instead of private data buffer eliminated from the file object, common sector buffer in the filesystem object <tt>FATFS</tt> is used for the file data transfer.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This option switches support for the exFAT filesystem in addition to the FAT/FAT32 filesystem, Enabled (1) or Disabled (0). To enable exFAT, also LFN must be enabled and configureing <tt>FF_LFN_UNICODE &gt;= 1</tt> and <tt>FF_MAX_LFN == 255</tt> is recommended for full-featured exFAT function. Note that enabling exFAT discards ANSI C (C89) compatibility because of need for 64-bit integer type.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Use RTC (0) or Do not use RTC (1). This option controls timestamp function. If the system does not have any RTC function or valid timestamp is not needed, set <tt>FF_FS_NORTC</tt> to 1 to disable the timestamp function. Every objects modified by FatFs will have a fixed timestamp defined by <tt>FF_NORTC_MON</tt>, <tt>FF_NORTC_MDAY</tt> and <tt>FF_NORTC_YEAR</tt>. To use the timestamp function, set <tt>FF_FS_NORTC == 0</tt> and add <tt>get_fattime</tt> function to the project to get current time form the RTC. This option has no effect at read-only configuration.</p>
Config.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Disable (0) or Enable (1). This option switches the re-entrancy (thread safe) of the FatFs module itself. Note that file/directory access to the different volume is always re-entrant and it can work simultaneously regardless of this option but volume control functions. <tt>f_mount</tt>, <tt>f_mkfs</tt> and <tt>f_fdisk</tt>, are always not re-entrant. Only file/directory access to the same volume, in other words, exclusive use of each filesystem object, is under control of this function. To enable this feature, also user provided synchronization handlers, <tt>ff_req_grant</tt>, <tt>ff_rel_grant</tt>, <tt>ff_del_syncobj</tt> and <tt>ff_cre_syncobj</tt>, need to be added to the project. Sample code is available in <tt>ffsystem.c</tt>.</p>
Core_cm3.c (f:\stm32f1-demo\core):  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
Core_cm3.c (f:\stm32f1-demo\core):  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
Core_cm3.c (f:\stm32f1-demo\core):  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
Core_cm3.c (f:\stm32f1-demo\core):   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
Core_cm3.h (f:\stm32f1-demo\core):#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
Core_cm3.h (f:\stm32f1-demo\core):#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
Core_cm3.h (f:\stm32f1-demo\core):#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
Core_cm3.h (f:\stm32f1-demo\core):#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
Core_cm3.h (f:\stm32f1-demo\core):#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
Core_cm3.h (f:\stm32f1-demo\core):#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
Core_cm3.h (f:\stm32f1-demo\core):#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
Core_cm3.h (f:\stm32f1-demo\core):  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
Core_cm3.h (f:\stm32f1-demo\core):  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
Core_cm3.h (f:\stm32f1-demo\core):#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
Core_cm3.h (f:\stm32f1-demo\core):#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
Core_cm3.h (f:\stm32f1-demo\core):#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
Core_cm3.h (f:\stm32f1-demo\core):#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
Core_cm3.h (f:\stm32f1-demo\core):  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
Core_cm3.h (f:\stm32f1-demo\core):  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
Core_cm3.h (f:\stm32f1-demo\core):#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
Core_cm3.h (f:\stm32f1-demo\core):#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
Core_cm3.h (f:\stm32f1-demo\core):#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
Core_cm3.h (f:\stm32f1-demo\core):#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
Core_cm3.h (f:\stm32f1-demo\core):  __regFaultMask = (faultMask & 1);
Core_cm3.h (f:\stm32f1-demo\core):  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
Core_cm3.h (f:\stm32f1-demo\core):  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
Core_cm3.h (f:\stm32f1-demo\core): * @return         1 = interrupt pending, 0 = interrupt not pending
Core_cm3.h (f:\stm32f1-demo\core): * Read the pending register in NVIC and return 1 if its status is pending, 
Core_cm3.h (f:\stm32f1-demo\core):  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
Core_cm3.h (f:\stm32f1-demo\core):  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
Core_cm3.h (f:\stm32f1-demo\core):  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
Core_cm3.h (f:\stm32f1-demo\core): * @return         1 = interrupt active, 0 = interrupt not active
Core_cm3.h (f:\stm32f1-demo\core): * Read the active register in NVIC and returns 1 if its status is active, 
Core_cm3.h (f:\stm32f1-demo\core):  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
Core_cm3.h (f:\stm32f1-demo\core):           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
Core_cm3.h (f:\stm32f1-demo\core):           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
Core_cm3.h (f:\stm32f1-demo\core):  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
Core_cm3.h (f:\stm32f1-demo\core):  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
Core_cm3.h (f:\stm32f1-demo\core): * @return  1 = failed, 0 = successful
Core_cm3.h (f:\stm32f1-demo\core):  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
Core_cm3.h (f:\stm32f1-demo\core):  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
Core_cm3.h (f:\stm32f1-demo\core):  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
Core_cm3.h (f:\stm32f1-demo\core):  while(1);                                                    /* wait until reset */
Core_cm3.h (f:\stm32f1-demo\core): * @return      received character, -1 = no character received
Core_cm3.h (f:\stm32f1-demo\core):  int ch = -1;                               /* no character available */
Core_cm3.h (f:\stm32f1-demo\core): * @return      1 = character available, 0 = no character available
Core_cm3.h (f:\stm32f1-demo\core): * The function returns '1' if a character is available and '0' if no character is available. 
Core_cm3.h (f:\stm32f1-demo\core):    return (1);                                 /*    character available */
Css_e.css (f:\stm32f1-demo\librrary\fat32\documents):pre {border: 1px dashed gray; margin: 0.5em 1em; padding: 0.5em; line-height: 1.2em; font-size: 85%; font-family: "Consolas", "Courier New", monospace; background-color: white;}
Css_e.css (f:\stm32f1-demo\librrary\fat32\documents):h3 {font-size: 1.5em; font-family: sans-serif; margin: 1.5em 0 0.5em;}
Css_e.css (f:\stm32f1-demo\librrary\fat32\documents):h4 {font-size: 1.2em; font-family: sans-serif; margin: 2em 0 0.2em;}
Css_e.css (f:\stm32f1-demo\librrary\fat32\documents):td {background-color: white; border: 1px solid black; padding: 0 3px; vertical-align: top; line-height: 1.3em;}
Da.c (f:\stm32f1-demo\drivers\dac):            GPIO_InitStructure.GPIO_Pin = DA_IO_CONFIG[i][1] & 0x0000ffff;
Da.c (f:\stm32f1-demo\drivers\dac):                case 1:
Da.h (f:\stm32f1-demo\drivers):#define POARTA  1
Delay.c (f:\stm32f1-demo\drivers\delay):            Time_out_flag = 1;
Delay.c (f:\stm32f1-demo\drivers\delay):        frameCounter = 1;
Delay.h (f:\stm32f1-demo\drivers):#define TRUE  1
Delay.h (f:\stm32f1-demo\drivers):#define COUNT_1HZ     1000      // Number of 1000 Hz frames for   1 Hz Loop
Delay.h (f:\stm32f1-demo\drivers):#define COUNT_0_5HZ     2000      // Number of 1000 Hz frames for   1 Hz Loop
Delay.h (f:\stm32f1-demo\drivers):#define CYCCNTENA   (1 << 0)
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dht11.c (f:\stm32f1-demo\modules\dht11):    DHT11_SET;  //DQ=1
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dht11.c (f:\stm32f1-demo\modules\dht11):    //delay_us(1);
Dht11.c (f:\stm32f1-demo\modules\dht11):        //delay_us(1);
Dht11.c (f:\stm32f1-demo\modules\dht11):        return 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):        //delay_us(1);
Dht11.c (f:\stm32f1-demo\modules\dht11):        return 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):        //delay_us(1);
Dht11.c (f:\stm32f1-demo\modules\dht11):        return 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dht11.c (f:\stm32f1-demo\modules\dht11):        //delay_us(1);
Dht11.c (f:\stm32f1-demo\modules\dht11):        //delay_us(1);
Dht11.c (f:\stm32f1-demo\modules\dht11):        return 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dht11.c (f:\stm32f1-demo\modules\dht11):        dat <<= 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):返回参数：0,正常;1,读取失败
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dht11.c (f:\stm32f1-demo\modules\dht11):        if((buf[0] + buf[1] + buf[2] + buf[3]) == buf[4])
Dht11.c (f:\stm32f1-demo\modules\dht11):            SENSOR_DHT_11.humidity = (float)(buf[0] * 256 + buf[1]) / 10.0;
Dht11.c (f:\stm32f1-demo\modules\dht11):            return 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):        return 1;
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dht11.c (f:\stm32f1-demo\modules\dht11):创建时间: 2018-1-13 by zam
Dioctl.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>GET_SECTOR_COUNT</td><td>Returns number of available sectors on the drive into the <tt>DWORD</tt> variable pointed by <tt class="arg">buff</tt>. This command is used in only <tt>f_mkfs</tt> and <tt>f_fdisk</tt> function to determine the volume/partition size to be created. Required at <tt>FF_USE_MKFS == 1</tt> or <tt>FF_MULTI_PARTITION == 1</tt>.</td></tr>
Dioctl.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>GET_BLOCK_SIZE</td><td>Returns erase block size of the flash memory media in unit of sector into the <tt>DWORD</tt> variable pointed by <tt class="arg">buff</tt>. The allowable value is 1 to 32768 in power of 2. Return 1 if the erase block size is unknown or non flash memory media. This command is used by only <tt>f_mkfs</tt> function and it attempts to align data area on the erase block boundary. Required at <tt>FF_USE_MKFS == 1</tt>.</td></tr>
Dioctl.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>CTRL_TRIM</td><td>Informs the device the data on the block of sectors is no longer needed and it can be erased. The sector block is specified by a <tt>DWORD</tt> array {&lt;start sector&gt;, &lt;end sector&gt;} pointed by <tt class="arg">buff</tt>. This is an identical command to Trim of ATA device. Nothing to do for this command if this funcion is not supported or not a flash memory device. FatFs does not check the result code and the file function is not affected even if the sector block was not erased well. This command is called on remove a cluster chain and in the <tt>f_mkfs</tt> function. Required at <tt>FF_USE_TRIM == 1</tt>.</td></tr>
Dioctl.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The disk_ioctl function is not needed when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 1</tt> and <tt><a href="config.html#max_ss">FF_MAX_SS</a> == <a href="config.html#max_ss">FF_MIN_SS</a></tt>.</p>
Diskio.c (f:\stm32f1-demo\librrary\fat32):#define DEV_MMC     1   /* Example: Map MMC/SD card to physical drive 1 */
Diskio.c (f:\stm32f1-demo\librrary\fat32):           | ((DWORD)1 << 21)              /* Month = 1 */
Diskio.c (f:\stm32f1-demo\librrary\fat32):           | ((DWORD)1 << 16)              /* Day_m = 1*/
Diskio.c (f:\stm32f1-demo\librrary\fat32):           | ((DWORD)0 >> 1);              /* Sec = 0 */
Diskio.h (f:\stm32f1-demo\librrary):	RES_ERROR,		/* 1: R/W Error */
Diskio.h (f:\stm32f1-demo\librrary):#define GET_SECTOR_COUNT	1	/* Get media size (needed at _USE_MKFS == 1) */
Diskio.h (f:\stm32f1-demo\librrary):#define GET_BLOCK_SIZE		3	/* Get erase block size (needed at _USE_MKFS == 1) */
Diskio.h (f:\stm32f1-demo\librrary):#define CTRL_TRIM			4	/* Inform device that the data on the block of sectors is no longer used (needed at _USE_TRIM == 1) */
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        delay_us(1);
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        return 1;
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        delay_us(1);
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        return 1;
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        date = 1;
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        dat = (j << 7) | (dat >> 1);
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):    for(j = 1; j <= 8; j++)
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):        cmd = cmd >> 1;
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):            DS18B20_RESET;  // Write 1
Ds18b20.c (f:\stm32f1-demo\modules\ds18b20):    else temp = 1;              //温度为正
Dwrite.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This function is not needed when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 1</tt>.</p>
Expand.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Operation mode. Prepare only (0) or Allocate now (1).</dd>
Expand.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The <tt>f_expand</tt> function prepares or allocates a contiguous data area to the file. When <tt class="arg">opt</tt> is 1, the function allocates a contiguous data area to the file. Unlike expansion of file by <tt>f_lseek</tt> function, the file must be truncated prior to use this function and read/write pointer of the file stays at top of the file after the function. The file content allocated with this function is <em>undefined</em> because no data is written to the file in this process. The function can fail with <tt>FR_DENIED</tt> due to some reasons below.</p>
Expand.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt>FF_USE_EXPAND == 1</tt> and <tt>FF_FS_READONLY == 0</tt>.</p>
Expand.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    res = <em>f_expand</em>(fp, 104857600, 1);
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs r3, r3, #1;        ;more 8-word chunks to move?
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs r3, r3, #1    	;decrement word count
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ldrb r3, [r1], #1  	;read byte from src
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	strb r3, [r0], #1  	;write byte to dest
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs r2, r2, #1    	;--size (decrement loop count)
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ldrb	lr, [r1], #1  	;read byte from src
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs	r3, r3, #1    	;--m (decrement loop count)
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	strb	lr, [r12], #1  	;write byte to dest
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs r3, r3, #1    	;more 8-word chunks to move?
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs r3, r3, #1    	;decrement word count
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ldrb lr,[r1],#1  	;read byte from src
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs r2,r2,#1    	;--size (decrement loop count)
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	strb lr,[r12],#1  	;write byte to dest
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ldrb r3, [r1, #-1]!   ;load next byte from source
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	strb r3, [r2, #-1]!   ;store next byte to dest Nth
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ldrb     r0,[r3],#1        ;b1 = next byte from string 1
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ldrb     r4,[r1],#1        ;b2 = next byte from string 2
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs     r2,r2,#1          ;--n (decrement loop counter)
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	subs     r2,r2,#1          ;--nWords
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	teq      r2,#1             ;nWords == 1? (mismatch at EOS?)
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	bne      FindMismatch      ;jump if nWords != 1
Fast_copy.c (f:\stm32f1-demo\librrary\fast_copy):	ands     r0,r0,r6          ;mask off trailing bytes, string 1
Fattime.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Month (1..12)</dd>
Fattime.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Day of the month (1..31)</dd>
Fattime.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This function is not needed when <tt>FF_FS_READONLY == 1</tt> or <tt>FF_FS_NORTC == 1</tt>.</p>
Fdisk.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_readonly">FF_FS_READOLNY</a> == 0</tt>, <tt><a href="config.html#use_mkfs">FF_USE_MKFS</a> == 1</tt> and <tt><a href="config.html#multi_partition">FF_MULTI_PARTITION</a> == 1</tt>.</p>
Fdisk.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    <span class="c">/* Volume management table defined by user (required when FF_MULTI_PARTITION == 1) */</span>
Fdisk.html (f:\stm32f1-demo\librrary\fat32\documents\doc):        {0, 1},    <span class="c">/* "0:" ==> Physical drive 0, 1st partition */</span>
Fdisk.html (f:\stm32f1-demo\librrary\fat32\documents\doc):        {0, 2},    <span class="c">/* "1:" ==> Physical drive 0, 2nd partition */</span>
Fdisk.html (f:\stm32f1-demo\librrary\fat32\documents\doc):        {1, 0}     <span class="c">/* "2:" ==> Physical drive 1, auto detection */</span>
Fdisk.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    f_mkfs("1:", FM_ANY, work, sizeof work);    <span class="c">/* Create FAT volume on the logical drive 1 */</span>
Ff.c (f:\stm32f1-demo\librrary\fat32):/ 1. Redistributions of source code must retain the above copyright notice,
Ff.c (f:\stm32f1-demo\librrary\fat32):#define XDIR_NumLabel       1       /* exFAT: Number of volume label characters (BYTE) */
Ff.c (f:\stm32f1-demo\librrary\fat32):#define XDIR_NumSec         1       /* exFAT: Number of secondary entries (BYTE) */
Ff.c (f:\stm32f1-demo\librrary\fat32):#define PTE_StHead          1       /* MBR PTE: Start head */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN == 1
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_NORTC == 1
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NORTC_MDAY < 1 || FF_NORTC_MDAY > 31
Ff.c (f:\stm32f1-demo\librrary\fat32):    FATFS *fs;      /* Object ID 1, volume (NULL:blank entry) */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_VOLUMES < 1 || FF_VOLUMES > 10
Ff.c (f:\stm32f1-demo\librrary\fat32):static const BYTE LfnOfs[] = {1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30}; /* FAT: Offset of LFN characters in the directory entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN == 1     /* LFN enabled with static working buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):static WCHAR LfnBuf[FF_MAX_LFN + 1];        /* LFN working buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):#define DEF_NAMBUF      WCHAR lbuf[FF_MAX_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];   /* LFN working buffer and directory entry block scratchpad buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):#define DEF_NAMBUF      WCHAR lbuf[FF_MAX_LFN+1];   /* LFN working buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):#define INIT_NAMBUF(fs) { lfn = ff_memalloc((FF_MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+FF_MAX_LFN+1); }
Ff.c (f:\stm32f1-demo\librrary\fat32):#define INIT_NAMBUF(fs) { lfn = ff_memalloc((FF_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif  /* FF_USE_LFN == 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):    rv = ptr[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):    rv = rv << 8 | ptr[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):    rv = rv << 8 | ptr[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c <= DbcTbl[1]) return 1;                    /* 1st byte range 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;  /* 1st byte range 2 */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c <= DbcTbl[1]) return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c <= DbcTbl[5]) return 1;                    /* 2nd byte range 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;  /* 2nd byte range 2 */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;  /* 2nd byte range 3 */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c <= DbcTbl[5]) return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_LFN_UNICODE == 1     /* UTF-16 input */
Ff.c (f:\stm32f1-demo\librrary\fat32):            nf = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_LFN_UNICODE == 1 /* UTF-16 output */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(szb < 1 || IsSurrogate(wc)) return 0;    /* Buffer overflow or wrong code? */
Ff.c (f:\stm32f1-demo\librrary\fat32):        return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(szb < 1) return 0;   /* Buffer overflow? */
Ff.c (f:\stm32f1-demo\librrary\fat32):        return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(wc == 0 || szb < 1) return 0;    /* Invalid char or buffer overflow? */
Ff.c (f:\stm32f1-demo\librrary\fat32):    return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):int lock_fs(   /* 1:Ok, 0:timeout */
Ff.c (f:\stm32f1-demo\librrary\fat32):    int acc         /* Desired access type (0:Read mode open, 1:Write mode open, 2:Delete or rename) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            be = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    return (i == FF_FS_LOCK) ? 0 : 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    int acc     /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(acc >= 1 && Files[i].ctr) return 0;  /* Access violation (int err) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;  /* Set semaphore value */
Ff.c (f:\stm32f1-demo\librrary\fat32):    return i + 1;   /* Index number origin from 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):    UINT i          /* Semaphore index (1..) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK)     /* Write back the window */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);  /* Reflect it to 2nd FAT if needed */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK)
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->fs_type == FS_FAT32 && fs->fsi_flag == 1)    /* FAT32: Update FSInfo sector if needed */
Ff.c (f:\stm32f1-demo\librrary\fat32):            fs->winsect = fs->volbase + 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            disk_write(fs->pdrv, fs->win, fs->winsect, 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):DWORD get_fat(   /* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
Ff.c (f:\stm32f1-demo\librrary\fat32):        val = 1;    /* Internal error */
Ff.c (f:\stm32f1-demo\librrary\fat32):                val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);    /* Adjust bit position */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;  /* Number of clusters - 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):                        val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;   /* No data on the FAT, generate the value */
Ff.c (f:\stm32f1-demo\librrary\fat32):                        val = clst + 1;     /* Generate the value */
Ff.c (f:\stm32f1-demo\librrary\fat32):                val = 1;    /* Internal error */
Ff.c (f:\stm32f1-demo\librrary\fat32):                *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;     /* Put 1st byte */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); /* Put 2nd byte */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    DWORD ncl   /* Number of contiguous clusters to find (1..) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        bm = 1 << (val % 8);
Ff.c (f:\stm32f1-demo\librrary\fat32):                bm <<= 1;     /* Get bit value */
Ff.c (f:\stm32f1-demo\librrary\fat32):            bm = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    int bv      /* bit value to be set (0 or 1) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    bm = 1 << (clst % 8);                       /* Bit mask in the byte */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            while(bm <<= 1);        /* Next bit */
Ff.c (f:\stm32f1-demo\librrary\fat32):            bm = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            res = put_fat(obj->fs, cl, cl + 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):        res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(nxt == 1) return FR_INT_ERR;     /* Internal error? */
Ff.c (f:\stm32f1-demo\librrary\fat32):            fs->fsi_flag |= 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(ecl + 1 == nxt)      /* Is next cluster contiguous? */
Ff.c (f:\stm32f1-demo\librrary\fat32):                res = change_bitmap(fs, scl, ecl - scl + 1, 0); /* Mark the cluster block 'free' on the bitmap */
Ff.c (f:\stm32f1-demo\librrary\fat32):            rt[1] = clst2sect(fs, ecl) + fs->csize - 1; /* End of data area freed */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(nxt != clst + 1) break;  /* Not contiguous? */
Ff.c (f:\stm32f1-demo\librrary\fat32):DWORD create_chain(  /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(scl == 0 || scl >= fs->n_fatent) scl = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(cs < 2) return 1;                /* Test for insanity */
Ff.c (f:\stm32f1-demo\librrary\fat32):        ncl = find_bitmap(fs, scl, 1);              /* Find a free cluster */
Ff.c (f:\stm32f1-demo\librrary\fat32):        res = change_bitmap(fs, ncl, 1, 1);         /* Mark the cluster 'in use' */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(res == FR_INT_ERR) return 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(obj->stat == 2 && ncl != scl + 1)    /* Is the chain got fragmented? */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(ncl == clst + 1)     /* Is the cluster next to previous one? */
Ff.c (f:\stm32f1-demo\librrary\fat32):                obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;    /* Increment size of last framgent */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(obj->n_frag == 0) obj->n_frag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(res == FR_OK) obj->n_frag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            ncl = scl + 1;                      /* Test if next cluster is free */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(cs == 1 || cs == 0xFFFFFFFF) return cs;  /* Test for error */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(cs == 1 || cs == 0xFFFFFFFF) return cs;  /* Test for error */
Ff.c (f:\stm32f1-demo\librrary\fat32):        fs->fsi_flag |= 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;    /* Failed. Generate error status */
Ff.c (f:\stm32f1-demo\librrary\fat32):    tbl = fp->cltbl + 1;    /* Top of CLMT */
Ff.c (f:\stm32f1-demo\librrary\fat32):        szb = 1;    /* Use window buffer (single-sector writes may take a time) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    int stretch     /* 0: Do not stretch table, 1: Stretch table if needed */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if((ofs / SS(fs) & (fs->csize - 1)) == 0)       /* Cluster changed? */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(clst <= 1) return FR_INT_ERR;            /* Internal error */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(clst == 1) return FR_INT_ERR;            /* Internal error */
Ff.c (f:\stm32f1-demo\librrary\fat32):            res = dir_next(dp, 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):int cmp_lfn(     /* 1:matched, 0:not matched */
Ff.c (f:\stm32f1-demo\librrary\fat32):    i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;  /* Offset in the LFN buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):    for(wc = 1, s = 0; s < 13; s++)         /* Process all characters in the entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):    return 1;       /* The part of LFN matched */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
Ff.c (f:\stm32f1-demo\librrary\fat32):int pick_lfn(    /* 1:succeeded, 0:buffer overflow or invalid LFN entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):    i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13; /* Offset in the LFN buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):    for(wc = 1, s = 0; s < 13; s++)         /* Process all characters in the entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):    return 1;       /* The part of LFN is valid */
Ff.c (f:\stm32f1-demo\librrary\fat32):    BYTE ord,           /* LFN order (1-20) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    i = (ord - 1) * 13;             /* Get offset in the LFN working buffer */
Ff.c (f:\stm32f1-demo\librrary\fat32):                sr = (sr << 1) + (wc & 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):                wc >>= 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(j == i - 1) break;
Ff.c (f:\stm32f1-demo\librrary\fat32):        sum = (sum >> 1) + (sum << 7) + *dir++;
Ff.c (f:\stm32f1-demo\librrary\fat32):    szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
Ff.c (f:\stm32f1-demo\librrary\fat32):            sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
Ff.c (f:\stm32f1-demo\librrary\fat32):        sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
Ff.c (f:\stm32f1-demo\librrary\fat32):        sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
Ff.c (f:\stm32f1-demo\librrary\fat32):    sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif  /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
Ff.c (f:\stm32f1-demo\librrary\fat32):    sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
Ff.c (f:\stm32f1-demo\librrary\fat32):    mem_cpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
Ff.c (f:\stm32f1-demo\librrary\fat32):    nent = dirb[XDIR_NumSec] + 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        dp->obj.fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    dirb[1 * SZDIRE + XDIR_Type] = 0xC0;    /* C0 entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):    wc = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    dirb[XDIR_NumSec] = 1 + nc1;    /* Set secondary count (C0 + C1s) */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
Ff.c (f:\stm32f1-demo\librrary\fat32):#define dir_read_label(dp) dir_read(dp, 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):    int vol         /* Filtered by 0:file/directory or 1:volume label */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif  /* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL || FF_FS_RPATH >= 2 */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
Ff.c (f:\stm32f1-demo\librrary\fat32):        dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);   /* Set the allocated entry block offset */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        for(n = 1; n < 100; n++)
Ff.c (f:\stm32f1-demo\librrary\fat32):    nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;    /* Number of entries to allocate */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    res = dir_alloc(dp, 1);     /* Allocate an entry for SFN */
Ff.c (f:\stm32f1-demo\librrary\fat32):            fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_LFN_UNICODE >= 1 /* Unicode output */
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_FIND && FF_FS_MINIMIZE <= 1
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE >= 1   /* Unicode input */
Ff.c (f:\stm32f1-demo\librrary\fat32):int pattern_matching(  /* 0:not matched, 1:matched */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(*pat == 0 && inf) return 1;  /* (short circuit) */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    else nx = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(pattern_matching(pp, np, nm, nx)) return 1;  /* Test new branch (recurs upto number of wildcard blocks in the pattern) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(pc == 0) return 1;   /* Branch matched? (matched at end of both strings) */
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif /* FF_USE_FIND && FF_FS_MINIMIZE <= 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if((di == 1 && lfn[di - 1] == '.') ||
Ff.c (f:\stm32f1-demo\librrary\fat32):       (di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.'))      /* Is this segment a dot name? */
Ff.c (f:\stm32f1-demo\librrary\fat32):        wc = lfn[di - 1];
Ff.c (f:\stm32f1-demo\librrary\fat32):    while(di > 0 && lfn[di - 1] != '.') di--;   /* Find last dot (di<=si: no extension) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(i >= ni - 1)             /* Field overflow? */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    b |= 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;  /* Reject invalid DBC */
Ff.c (f:\stm32f1-demo\librrary\fat32):int get_ldnumber(   /* Returns logical drive number (-1:invalid drive) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    int vol = -1;
Ff.c (f:\stm32f1-demo\librrary\fat32):BYTE check_fs(  /* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;     /* Check if exFAT VBR */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):        i = LD2PT(vol);                 /* Partition number: 0:auto, 1-4:forced */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(fmt == 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;    /* Check exFAT version (must be version 1.0) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(1 << fs->win[BPB_BytsPerSecEx] != SS(fs))    /* (BPB_BytsPerSecEx must be equal to the physical sector size) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;  /* Last LBA + 1 of the volume */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->n_fats != 1) return FR_NO_FILESYSTEM;    /* (Supports only 1 FAT) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        fs->csize = 1 << fs->win[BPB_SecPerClusEx];     /* Cluster size */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->csize == 0) return FR_NO_FILESYSTEM;     /* (Must be 1..32768) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;     /* (Must be 1 or 2) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;    /* (Must be power of 2) */
Ff.c (f:\stm32f1-demo\librrary\fat32):                     fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;   /* (BPB_FATSz must not be less than the size needed) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fmt == FS_FAT32              /* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):           && ld_word(fs->win + BPB_FSInfo32) == 1
Ff.c (f:\stm32f1-demo\librrary\fat32):           && move_window(fs, bsect + 1) == FR_OK)
Ff.c (f:\stm32f1-demo\librrary\fat32):#if (FF_FS_NOFSINFO & 1) == 0
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN == 1
Ff.c (f:\stm32f1-demo\librrary\fat32):    BYTE opt            /* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
Ff.c (f:\stm32f1-demo\librrary\fat32):                res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);     /* Check if the file can be used */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    fs->dirbuf[XDIR_GenFlags] = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                        fs->last_clst = fp->obj.sclust - 1;     /* Reuse the cluster hole */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                            fs->last_clst = cl - 1;     /* Reuse the cluster hole */
Ff.c (f:\stm32f1-demo\librrary\fat32):            fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);  /* Lock the file for this session */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(clst <= 1) res = FR_INT_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):                        if(disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):            csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));    /* Sector offset in the cluster */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)    ABORT(fs, FR_DISK_ERR);  /* Fill sector cache */
Ff.c (f:\stm32f1-demo\librrary\fat32):            csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);    /* Sector offset in the cluster */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(clst == 1) ABORT(fs, FR_INT_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):               disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)
Ff.c (f:\stm32f1-demo\librrary\fat32):        fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                        fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;   /* Update file allocation information */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_RPATH >= 1
Ff.c (f:\stm32f1-demo\librrary\fat32):                res = dir_sdi(&dj, 1 * SZDIRE); /* Get parent directory */
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif /* FF_FS_RPATH >= 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):                        if(cl <= 1) ABORT(fs, FR_INT_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                    while(cl == pcl + 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):                fp->clust = clmt_clust(fp, ofs - 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):                dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):                        if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);  /* Load current sector */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;     /* Clip at 4 GiB - 1 if at FATxx */
Ff.c (f:\stm32f1-demo\librrary\fat32):               (ofs - 1) / bcs >= (ifptr - 1) / bcs)   /* When seek to same or following cluster, */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);   /* start from the current cluster */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(clst == 1) ABORT(fs, FR_INT_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);    /* Fill sector cache */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_FS_MINIMIZE <= 1
Ff.c (f:\stm32f1-demo\librrary\fat32):                    if(stat == 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):                            if(!(bm & 1)) nfree++;
Ff.c (f:\stm32f1-demo\librrary\fat32):                            bm >>= 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                        i = (i + 1) % SS(fs);
Ff.c (f:\stm32f1-demo\librrary\fat32):            fs->fsi_flag |= 1;      /* FAT32: FSInfo is to be updated */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(ncl == 1) res = FR_INT_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK)
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(dcl == 1) res = FR_INT_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):                    dir[SZDIRE + 1] = '.';
Ff.c (f:\stm32f1-demo\librrary\fat32):                    fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                    fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                        fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                                dir = fs->win + SZDIRE * 1; /* Ptr to .. entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):                                if(res == FR_OK && dir[1] == '.')
Ff.c (f:\stm32f1-demo\librrary\fat32):                                    fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):#endif /* FF_FS_MINIMIZE <= 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE >= 1   /* Unicode output */
Ff.c (f:\stm32f1-demo\librrary\fat32):        while(di && dirvn[di - 1] == ' ') di--;                 /* Snip trailing spaces */
Ff.c (f:\stm32f1-demo\librrary\fat32):            fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                    res = dir_alloc(&dj, 1);    /* Allocate an entry */
Ff.c (f:\stm32f1-demo\librrary\fat32):                        fs->wflag = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):    BYTE opt        /* Operation mode 0:Find and prepare or 1:Find and allocate */
Ff.c (f:\stm32f1-demo\librrary\fat32):    tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 0); /* Number of clusters required */
Ff.c (f:\stm32f1-demo\librrary\fat32):                res = change_bitmap(fs, scl, tcl, 1);   /* Mark the cluster block 'in use' */
Ff.c (f:\stm32f1-demo\librrary\fat32):                lclst = scl + tcl - 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                lclst = scl - 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(n == 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):                    res = put_fat(fs, clst, (n == 1) ? 0xFFFFFFFF : clst + 1);
Ff.c (f:\stm32f1-demo\librrary\fat32):                lclst = scl - 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                fs->fsi_flag |= 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));    /* Sector offset in the cluster */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(clst <= 1) ABORT(fs, FR_INT_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):    const UINT n_fats = 1;      /* Number of FATs for FAT/FAT32 volume (1 or 2) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};  /* Cluster size boundary for FAT volume (4Ks unit) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};    /* Cluster size boundary for FAT32 volume (128Ks unit) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    part = LD2PT(vol);  /* Partition (0:create as new, 1-4:get from partition table) */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;     /* Erase block to align data area */
Ff.c (f:\stm32f1-demo\librrary\fat32):    if(ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):    if((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;  /* Check if au is valid */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);   /* Load MBR */
Ff.c (f:\stm32f1-demo\librrary\fat32):        pte = buf + (MBR_Table + (part - 1) * SZ_PTE);
Ff.c (f:\stm32f1-demo\librrary\fat32):        tbl[1] = b_vol + sz_vol - 1;    /* Inform the device the volume area may be erased */
Ff.c (f:\stm32f1-demo\librrary\fat32):        sz_fat = ((sz_vol / au + 2) * 4 + ss - 1) / ss;         /* Number of FAT sectors */
Ff.c (f:\stm32f1-demo\librrary\fat32):        b_data = (b_fat + sz_fat + sz_blk - 1) & ~(sz_blk - 1); /* Align data area to the erase block boundary */
Ff.c (f:\stm32f1-demo\librrary\fat32):        tbl[0] = (szb_bit + au * ss - 1) / (au * ss);   /* Number of allocation bitmap clusters */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    for(j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;   /* Get run length of no-case block */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    st = 1;         /* Do not compress short run */
Ff.c (f:\stm32f1-demo\librrary\fat32):                case 1:
Ff.c (f:\stm32f1-demo\librrary\fat32):            sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);
Ff.c (f:\stm32f1-demo\librrary\fat32):                n = (i + ss - 1) / ss;
Ff.c (f:\stm32f1-demo\librrary\fat32):        tbl[1] = (szb_case + au * ss - 1) / (au * ss);  /* Number of up-case table clusters */
Ff.c (f:\stm32f1-demo\librrary\fat32):        tbl[2] = 1;                                     /* Number of root dir clusters */
Ff.c (f:\stm32f1-demo\librrary\fat32):        nsect = (szb_bit + ss - 1) / ss; /* Start of bitmap and number of sectors */
Ff.c (f:\stm32f1-demo\librrary\fat32):        nb = tbl[0] + tbl[1] + tbl[2];                  /* Number of clusters in-use by system */
Ff.c (f:\stm32f1-demo\librrary\fat32):            for(b = 1; nb != 0 && i < szb_buf; buf[i] |= b, b <<= 1, nb--) ;
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(cl == 0)     /* Set entry 0 and 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    st_dword(buf + i, (nb > 1) ? cl + 1 : 0xFFFFFFFF);
Ff.c (f:\stm32f1-demo\librrary\fat32):        buf[SZDIRE * 1 + 0] = 0x81;     /* 81 entry (allocation bitmap) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        st_dword(buf + SZDIRE * 1 + 20, 2);
Ff.c (f:\stm32f1-demo\librrary\fat32):        st_dword(buf + SZDIRE * 1 + 24, szb_bit);
Ff.c (f:\stm32f1-demo\librrary\fat32):        sect = b_data + au * (tbl[0] + tbl[1]);
Ff.c (f:\stm32f1-demo\librrary\fat32):            st_dword(buf + BPB_RootClusEx, 2 + tbl[0] + tbl[1]);    /* Root dir cluster # */
Ff.c (f:\stm32f1-demo\librrary\fat32):            st_word(buf + BPB_FSVerEx, 0x100);                      /* Filesystem version (1.00) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            for(buf[BPB_BytsPerSecEx] = 0, i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;  /* Log2 of sector size [byte] */
Ff.c (f:\stm32f1-demo\librrary\fat32):            for(buf[BPB_SecPerClusEx] = 0, i = au; i >>= 1; buf[BPB_SecPerClusEx]++) ;  /* Log2 of cluster size [sector] */
Ff.c (f:\stm32f1-demo\librrary\fat32):            buf[BPB_NumFATsEx] = 1;                 /* Number of FATs */
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(i != BPB_VolFlagEx && i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum32(buf[i], sum);
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):            /* Extended bootstrap record (+1..+8) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            for(j = 1; j < 9; j++)
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
Ff.c (f:\stm32f1-demo\librrary\fat32):                    for(i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;    /* Get from table */
Ff.c (f:\stm32f1-demo\librrary\fat32):                sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;    /* FAT size [sector] */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    for(i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;    /* Get from table */
Ff.c (f:\stm32f1-demo\librrary\fat32):                    n = (n_clst * 3 + 1) / 2 + 3;   /* FAT size [byte] */
Ff.c (f:\stm32f1-demo\librrary\fat32):                sz_fat = (n + ss - 1) / ss;     /* FAT size [sector] */
Ff.c (f:\stm32f1-demo\librrary\fat32):                sz_rsv = 1;                     /* Number of reserved sectors */
Ff.c (f:\stm32f1-demo\librrary\fat32):            n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;   /* Next nearest erase block from current data base */
Ff.c (f:\stm32f1-demo\librrary\fat32):        while(1);
Ff.c (f:\stm32f1-demo\librrary\fat32):        tbl[1] = b_vol + sz_vol - 1;    /* Inform the device the volume area can be erased */
Ff.c (f:\stm32f1-demo\librrary\fat32):            st_word(buf + BPB_FSInfo32, 1);             /* Offset of FSINFO sector (VBR + 1) */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(disk_write(pdrv, buf, b_vol, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);  /* Write it to the VBR sector */
Ff.c (f:\stm32f1-demo\librrary\fat32):            disk_write(pdrv, buf, b_vol + 6, 1);        /* Write backup VBR (VBR + 6) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            st_dword(buf + FSI_Free_Count, n_clst - 1); /* Number of free clusters */
Ff.c (f:\stm32f1-demo\librrary\fat32):            disk_write(pdrv, buf, b_vol + 7, 1);        /* Write backup FSINFO (VBR + 7) */
Ff.c (f:\stm32f1-demo\librrary\fat32):            disk_write(pdrv, buf, b_vol + 1, 1);        /* Write original FSINFO (VBR + 1) */
Ff.c (f:\stm32f1-demo\librrary\fat32):                st_dword(buf + 4, 0xFFFFFFFF);  /* Entry 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):                st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);   /* Entry 0 and 1 */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);   /* Read the MBR */
Ff.c (f:\stm32f1-demo\librrary\fat32):        buf[MBR_Table + (part - 1) * SZ_PTE + PTE_System] = sys;        /* Set system ID */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);  /* Write it back to the MBR */
Ff.c (f:\stm32f1-demo\librrary\fat32):            pte[PTE_StHead] = 1;                /* Start head */
Ff.c (f:\stm32f1-demo\librrary\fat32):            pte[PTE_StSec] = 1;                 /* Start sector */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);  /* Write it to the MBR */
Ff.c (f:\stm32f1-demo\librrary\fat32):    e_hd = n - 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            s_hd = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        e_cyl = b_cyl + p_cyl - 1;  /* End cylinder */
Ff.c (f:\stm32f1-demo\librrary\fat32):        p[1] = s_hd;                        /* Start head */
Ff.c (f:\stm32f1-demo\librrary\fat32):        p[2] = (BYTE)(((b_cyl >> 2) & 0xC0) | 1);   /* Start sector */
Ff.c (f:\stm32f1-demo\librrary\fat32):    res = (disk_write(pdrv, buf, 0, 1) == RES_OK && disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && ((FF_LFN_UNICODE == 1 && FF_STRF_ENCODE == 3) || (FF_LFN_UNICODE == 2 && FF_STRF_ENCODE != 3))
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE == 1 && FF_STRF_ENCODE == 3
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE == 1   /* UTF-16 output */
Ff.c (f:\stm32f1-demo\librrary\fat32):    while(nc < len - 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):        f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(rc != 1) break;
Ff.c (f:\stm32f1-demo\librrary\fat32):            f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(rc != 1 || !dbc_2nd(s[0])) continue;
Ff.c (f:\stm32f1-demo\librrary\fat32):#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2    /* Read a character in UTF-16LE/BE */
Ff.c (f:\stm32f1-demo\librrary\fat32):    while(nc < len - 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):        wc = (FF_STRF_ENCODE == 1) ? s[1] << 8 | s[0] : s[0] << 8 | s[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):        f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(rc != 1) break;
Ff.c (f:\stm32f1-demo\librrary\fat32):                ct = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):                f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):                if(rc != 1 || (s[0] & 0xC0) != 0x80) break;
Ff.c (f:\stm32f1-demo\librrary\fat32):        f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(rc != 1) break;
Ff.c (f:\stm32f1-demo\librrary\fat32):            f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(rc != 1 || !dbc_2nd(s[0])) continue;
Ff.c (f:\stm32f1-demo\librrary\fat32):        dc = (FF_STRF_ENCODE == 1) ? s[1] << 8 | s[0] : s[0] << 8 | s[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):            wc = (FF_STRF_ENCODE == 1) ? s[1] << 8 | s[0] : s[0] << 8 | s[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(dc < 0x80)       /* 1-byte */
Ff.c (f:\stm32f1-demo\librrary\fat32):    while(nc < len - 1)
Ff.c (f:\stm32f1-demo\librrary\fat32):        f_read(fp, s, 1, &rc);
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(rc != 1) break;
Ff.c (f:\stm32f1-demo\librrary\fat32):    int idx, nchr;  /* Write index of buf[] (-1:error), number of encoding units written */
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE == 1
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && (FF_LFN_UNICODE == 1 || (FF_LFN_UNICODE == 2 && (FF_STRF_ENCODE != 3)))
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE >= 1
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE == 1   /* UTF-16 input */
Ff.c (f:\stm32f1-demo\librrary\fat32):        if(wc < 0x80)           /* 1-byte */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if((BYTE)c < 0x80) break;                   /* 1-byte? */
Ff.c (f:\stm32f1-demo\librrary\fat32):            if(((BYTE)c & 0xE0) == 0xC0) pb->ct = 1;    /* 2-byte? */
Ff.c (f:\stm32f1-demo\librrary\fat32):        pb->buf[i++] = pb->bs[1];
Ff.c (f:\stm32f1-demo\librrary\fat32):#if FF_USE_LFN && FF_LFN_UNICODE >= 1 && FF_STRF_ENCODE != 3
Ff.c (f:\stm32f1-demo\librrary\fat32):#elif FF_STRF_ENCODE == 1       /* Write a character in UTF-16LE */
Ff.c (f:\stm32f1-demo\librrary\fat32):        i = (n == (UINT)i) ? 0 : -1;
Ff.c (f:\stm32f1-demo\librrary\fat32):            f = 1;
Ff.c (f:\stm32f1-demo\librrary\fat32):        d = (f & 1) ? '0' : ' ';
Ff.h (f:\stm32f1-demo\librrary):/ 1. Redistributions of source code must retain the above copyright notice,
Ff.h (f:\stm32f1-demo\librrary):	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
Ff.h (f:\stm32f1-demo\librrary):#if FF_USE_LFN && FF_LFN_UNICODE == 1 	/* Unicode in UTF-16 encoding */
Ff.h (f:\stm32f1-demo\librrary):	BYTE	n_fats;			/* Number of FATs (1 or 2) */
Ff.h (f:\stm32f1-demo\librrary):	DWORD	n_cont;			/* Size of first fragment - 1 (valid when stat == 3) */
Ff.h (f:\stm32f1-demo\librrary):	UINT	lockid;			/* File lock ID origin from 1 (index of file semaphore table Files[]) */
Ff.h (f:\stm32f1-demo\librrary):	BYTE	fn[12];			/* SFN (in/out) {body[8],ext[3],status[1]} */
Ff.h (f:\stm32f1-demo\librrary):	TCHAR	altname[FF_SFN_BUF + 1];/* Altenative file name */
Ff.h (f:\stm32f1-demo\librrary):	TCHAR	fname[FF_LFN_BUF + 1];	/* Primary file name */
Ff.h (f:\stm32f1-demo\librrary):	TCHAR	fname[12 + 1];	/* File name */
Ff.h (f:\stm32f1-demo\librrary):	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
Ff.h (f:\stm32f1-demo\librrary):#define EOF (-1)
Ff.h (f:\stm32f1-demo\librrary):#if FF_USE_LFN >= 1						/* Code conversion (defined in unicode.c) */
Ff.h (f:\stm32f1-demo\librrary):#define CREATE_LINKMAP	((FSIZE_t)0 - 1)
Ff.h (f:\stm32f1-demo\librrary):#define FS_FAT12	1
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
Ffconf.h (f:\stm32f1-demo\librrary):/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename()
Ffconf.h (f:\stm32f1-demo\librrary):/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
Ffconf.h (f:\stm32f1-demo\librrary):/  1: Enable without LF-CRLF conversion.
Ffconf.h (f:\stm32f1-demo\librrary):/  f_findnext(). (0:Disable, 1:Enable 2:Enable with matching altname[] too) */
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches f_mkfs() function. (0:Disable or 1:Enable) */
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches fast seek function. (0:Disable or 1:Enable) */
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches f_expand function. (0:Disable or 1:Enable) */
Ffconf.h (f:\stm32f1-demo\librrary):/  (0:Disable or 1:Enable) Also FF_FS_READONLY needs to be 0 to enable this option. */
Ffconf.h (f:\stm32f1-demo\librrary):/  (0:Disable or 1:Enable) */
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches f_forward() function. (0:Disable or 1:Enable) */
Ffconf.h (f:\stm32f1-demo\librrary):/   850 - Latin 1
Ffconf.h (f:\stm32f1-demo\librrary):/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
Ffconf.h (f:\stm32f1-demo\librrary):/  requiers certain internal working buffer occupies (FF_MAX_LFN + 1) * 2 bytes and
Ffconf.h (f:\stm32f1-demo\librrary):/   1: Unicode in UTF-16 (TCHAR = WCHAR)
Ffconf.h (f:\stm32f1-demo\librrary):/* When FF_LFN_UNICODE >= 1 with LFN enabled, string I/O functions, f_gets(),
Ffconf.h (f:\stm32f1-demo\librrary):/   1: Unicode in UTF-16LE
Ffconf.h (f:\stm32f1-demo\librrary):/   1: Enable relative path. f_chdir() and f_chdrive() are available.
Ffconf.h (f:\stm32f1-demo\librrary):/   2: f_getcwd() function is available in addition to 1.
Ffconf.h (f:\stm32f1-demo\librrary):#define FF_VOLUMES		1
Ffconf.h (f:\stm32f1-demo\librrary):/* Number of volumes (logical drives) to be used. (1-10) */
Ffconf.h (f:\stm32f1-demo\librrary):/  When FF_STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
Ffconf.h (f:\stm32f1-demo\librrary):/  When this function is enabled (1), each logical drive number can be bound to
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches support for ATA-TRIM. (0:Disable or 1:Enable)
Ffconf.h (f:\stm32f1-demo\librrary):/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
Ffconf.h (f:\stm32f1-demo\librrary):/  bit0=1: Do not trust free cluster count in the FSINFO.
Ffconf.h (f:\stm32f1-demo\librrary):/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
Ffconf.h (f:\stm32f1-demo\librrary):/* This option switches support for exFAT filesystem. (0:Disable or 1:Enable)
Ffconf.h (f:\stm32f1-demo\librrary):#define FF_NORTC_MON	1
Ffconf.h (f:\stm32f1-demo\librrary):#define FF_NORTC_MDAY	1
Ffconf.h (f:\stm32f1-demo\librrary):/  any RTC function or valid timestamp is not needed, set FF_FS_NORTC = 1 to disable
Ffconf.h (f:\stm32f1-demo\librrary):/  These options have no effect at read-only configuration (FF_FS_READONLY = 1). */
Ffconf.h (f:\stm32f1-demo\librrary):/  is 1.
Ffconf.h (f:\stm32f1-demo\librrary):/   1: Enable re-entrancy. Also user provided synchronization handlers,
Ffsystem.c (f:\stm32f1-demo\librrary\fat32):int ff_cre_syncobj (	/* 1:Function succeeded, 0:Could not create the sync object */
Ffsystem.c (f:\stm32f1-demo\librrary\fat32)://	T_CSEM csem = {TA_TPRI,1,1};
Ffsystem.c (f:\stm32f1-demo\librrary\fat32):int ff_del_syncobj (	/* 1:Function succeeded, 0:Could not delete due to an error */
Ffsystem.c (f:\stm32f1-demo\librrary\fat32)://	return 1;
Ffsystem.c (f:\stm32f1-demo\librrary\fat32):int ff_req_grant (	/* 1:Got a grant to access the volume, 0:Could not get a grant */
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):/ 1. Redistributions of source code must retain the above copyright notice,
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):const WCHAR uc850[] = {	/*  CP850(Latin 1) to Unicode conversion table */
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				hi = sizeof CVTBL(uni2oem, FF_CODE_PAGE) / 4 - 1;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				if (n != 0) c = p[i * 2 + 1];
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):			hi = sizeof CVTBL(oem2uni, FF_CODE_PAGE) / 4 - 1;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):			if (n != 0) c = p[i * 2 + 1];
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				case 932 : p = uni2oem932; hi = sizeof uni2oem932 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				case 936 : p = uni2oem936; hi = sizeof uni2oem936 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				case 949 : p = uni2oem949; hi = sizeof uni2oem949 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				case 950 : p = uni2oem950; hi = sizeof uni2oem950 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):					if (n != 0) c = p[i * 2 + 1];
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):			case 932 : p = oem2uni932; hi = sizeof oem2uni932 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):			case 936 : p = oem2uni936; hi = sizeof oem2uni936 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):			case 949 : p = oem2uni949; hi = sizeof oem2uni949 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):			case 950 : p = oem2uni950; hi = sizeof oem2uni950 / 4 - 1; break;
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				if (n != 0) c = p[i * 2 + 1];
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):		/* Latin-1 Supplement */
Ffunicode.c (f:\stm32f1-demo\librrary\fat32):				case 1:	uc -= (uc - bc) & 1; break;	/* Case pairs */
Fifo.c (f:\stm32f1-demo\librrary\fifo):    l = MIN(len, fifo->Size - (fifo->Out & (fifo->Size - 1)));
Fifo.c (f:\stm32f1-demo\librrary\fifo):    MemCpy(buff, fifo->Data + (fifo->Out & (fifo->Size - 1)), l);
Fifo.c (f:\stm32f1-demo\librrary\fifo):    fixLen = MIN(len, fifo->Size - (fifo->In & (fifo->Size - 1)));
Fifo.c (f:\stm32f1-demo\librrary\fifo):    MemCpy(fifo->Data + (fifo->In & (fifo->Size - 1)), buff, fixLen);
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When relative path is enabled (<tt>FF_FS_RPATH &gt;= 1</tt>), specified path is followed from the root directory if a heading separator is exist. If not, it is followed from the current directory of the drive set by <a href="chdir.html"><tt>f_chdir</tt></a> function. Dot names are also allowed for the path names. The default drive is the current drive set by <a href="chdrive.html"><tt>f_chdrive</tt></a> function.</p>
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>Path name</td><td>FF_FS_RPATH == 0</td><td>FF_FS_RPATH &gt;= 1</td></tr>
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The path names are input/output in either ANSI/OEM code or Unicode depends on the configuration options. The type of arguments which specifies the path names is defined as <tt>TCHAR</tt>. It is an alias of <tt>char</tt> by default and the code set used for the path name string is ANSI/OEM specifid by <tt><a href="config.html#code_page">FF_CODE_PAGE</a></tt>. When <tt><a href="config.html#lfn_unicode">FF_LFN_UNICODE</a></tt> is set to 1, the type of the <tt>TCHAR</tt> is switched to <tt>WCHAR</tt> to support UTF-16 encoded Unicode string. When UTF-16 or UTF-8 is specified by this option, the full-featured LFN specification is supported and the Unicode specific characters, such as ♀糕, can also be used for the path name. It also affects data types and encoding of the string I/O functions. To define literal strings, <tt>_T(s)</tt> and <tt>_TEXT(s)</tt> macro are available to select either ANSI/OEM or Unicode automatically. The code shown below is an example to define the literal strings.</p>
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When <tt><a href="config.html#multi_partition">FF_MULTI_PARTITION = 1</a></tt> is specified by configuration option, each individual logical drive is bound to the partition on the physical drive specified by volume management table. The volume management table needs to be defined by user to resolve the mappings of logical drives and partitions. Following code is an example of a volume management table.</p>
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):Example: "0:", "1:" and "2:" are tied to three pri-partitions on the physical drive 0 (fixed drive)
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):         "3:" is tied to an FAT volume on the physical drive 1 (removable drive)
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    {0, 1},     <span class="c">/* "0:" ==> Physical drive 0, 1st partition */</span>
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    {0, 2},     <span class="c">/* "1:" ==> Physical drive 0, 2nd partition */</span>
Filename.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    {1, 0}      <span class="c">/* "3:" ==> Physical drive 1, auto detection */</span>
Findfirst.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The matching pattern can contain wildcard characters (<tt>?</tt> and <tt>*</tt>). A <tt>?</tt> matches an any character and an <tt>*</tt> matches an any string in length of zero or longer. When support of long file name is enabled, only <tt>fname[]</tt> is tested at <tt>FF_USE_FIND == 1</tt> and also <tt>altname[]</tt> is tested at <tt>FF_USE_FIND == 2</tt>. In this revision, there are some differences listed below between FatFs and standard systems in matching condition.</p>
Findfirst.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This is a wrapper function of <a href="opendir.html"><tt>f_opendir</tt></a> and <a href="readdir.html"><tt>f_readdir</tt></a> function. Available when <tt><a href="config.html#use_find">FF_USE_FIND</a> &gt;= 1</tt> and <tt><a href="config.html#fs_minimize">FF_FS_MINIMIZE</a> &lt;= 1</tt>.</p>
Findnext.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This is a wrapper function of <a href="readdir.html"><tt>f_readdir</tt></a> function. Available when <tt><a href="config.html#use_find">FF_USE_FIND</a> == 1</tt> and <tt><a href="config.html#fs_minimize">FF_FS_MINIMIZE</a> &lt;= 1</tt>.</p>
Fm25v01.c (f:\stm32f1-demo\modules\fm25v01):创建时间: 2018-1-05 by zam
Fm25v01.c (f:\stm32f1-demo\modules\fm25v01):创建时间: 2018-1-05 by zam
Fm25v01.c (f:\stm32f1-demo\modules\fm25v01):创建时间: 2018-1-05 by zam
Font.h (f:\stm32f1-demo\librrary):{0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x04,0x00,0x00},/*"!",1*/
Font.h (f:\stm32f1-demo\librrary):{0x00,0x00,0x04,0x06,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/*"1",17*/
Font.h (f:\stm32f1-demo\librrary):{0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x18,0x18,0x00,0x00},/*"!",1*/
Font.h (f:\stm32f1-demo\librrary):{0x00,0x00,0x00,0x08,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/*"1",17*/
Font.h (f:\stm32f1-demo\librrary):#if 1
Font.h (f:\stm32f1-demo\librrary):0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x04,0x00},/*"1",1*/
Font.h (f:\stm32f1-demo\librrary):0x19,0xFE,0x18,0xDB,0x30,0xD8,0x7F,0xD8,0x70,0xDB,0x01,0x9B,0x1F,0x9B,0x77,0x1F,/*1*/
Font.h (f:\stm32f1-demo\librrary):0x08,0x8C,0x03,0xF7,0x70,0x00,0x00,0x00,/*1*/
Font.h (f:\stm32f1-demo\librrary):0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*1*/
Forward.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#use_forward">FF_USE_FORWARD</a> == 1</tt>.</p>
Forward.html (f:\stm32f1-demo\librrary\fat32\documents\doc):        <span class="c">/* Return stream status (0: Busy, 1: Ready) */</span>
Forward.html (f:\stm32f1-demo\librrary\fat32\documents\doc):        if (FIFO_READY) cnt = 1;
Getcwd.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The <tt>f_getcwd</tt> function retrieves full path name of the current directory of the current drive. When <tt><a href="config.html#volumes">FF_VOLUMES</a></tt> is larger than 1, a logical drive number is added to top of the path name.</p>
Getfree.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    <span class="c">/* Get volume information and free clusters of drive 1 */</span>
Getfree.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    res = <em>f_getfree</em>("1:", &amp;fre_clust, &amp;fs);
Getlabel.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td></td><td>FF_FS_EXFAT == 0</td><td>FF_FS_EXFAT == 1</td></tr>
Getlabel.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>FF_LFN_UNICODE == 1</td><td>12 items</td><td>12 items</td></tr>
Getlabel.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#use_label">FF_USE_LABEL</a> == 1</tt>.</p>
Gets.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The read operation continues until a <tt>'\n'</tt> is stored, reached end of the file or the buffer is filled with <tt>len - 1</tt> characters. The read string is terminated with a <tt>'\0'</tt>. When no character to read or any error occured during read operation, it returns a null pointer. The status of EOF and error can be examined with <tt>f_eof</tt> and <tt>f_error</tt> function.</p>
Gets.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When FatFs is configured to Unicode API (<tt><a href="config.html#lfn_unicode">FF_LFN_UNICODE</a> >= 1</tt>), data types on the srting fuctions, <tt>f_putc</tt>, <tt>f_puts</tt>, <tt>f_printf</tt> and <tt>f_gets</tt>, is also switched to Unicode. The character encoding <em>on the file</em> to be read via this function is assumed as <a href="config.html#strf_encode"><tt>FF_STRF_ENCODE</tt></a>. If the character encoding on the file differs from that on the API, it is converted in this function. In this case, input characters with wrong encoding will be lost.<p>
Gets.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This is a wrapper function of <a href="read.html"><tt>f_read</tt></a> function. Available when <tt><a href="config.html#use_strfunc">FF_USE_STRFUNC</a> &gt;= 1</tt>. When it is set to 2, <tt>'\r'</tt>s contained in the file are stripped out.</p>
GUI.c (f:\stm32f1-demo\librrary\gui):    u16 width = ex - sx + 1; //得到填充的宽度
GUI.c (f:\stm32f1-demo\librrary\gui):    u16 height = ey - sy + 1; //高度
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(sx, sy, ex - 1, ey - 1); //设置显示窗口
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1); //恢复窗口设置为全屏
GUI.c (f:\stm32f1-demo\librrary\gui):    if(delta_x > 0)incx = 1; //设置单步方向
GUI.c (f:\stm32f1-demo\librrary\gui):        incx = -1;
GUI.c (f:\stm32f1-demo\librrary\gui):    if(delta_y > 0)incy = 1;
GUI.c (f:\stm32f1-demo\librrary\gui):        incy = -1;
GUI.c (f:\stm32f1-demo\librrary\gui):    for(t = 0; t <= distance + 1; t++) //画线输出
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式  0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(x, y, x + size / 2 - 1, y + size - 1); //设置单个文字显示窗口
GUI.c (f:\stm32f1-demo\librrary\gui):                temp >>= 1;
GUI.c (f:\stm32f1-demo\librrary\gui):                temp >>= 1;
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1); //恢复窗口为全屏
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式  0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):        if(x > (lcddev.width - 1) || y > (lcddev.height - 1))
GUI.c (f:\stm32f1-demo\librrary\gui):                temp <<= 1;
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式   0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):        if(x > (lcddev.width - 1) || y > (lcddev.height - 1))
GUI.c (f:\stm32f1-demo\librrary\gui):    u32 result = 1;
GUI.c (f:\stm32f1-demo\librrary\gui):        temp = (num / mypow(10, len - t - 1)) % 10;
GUI.c (f:\stm32f1-demo\librrary\gui):        if(enshow == 0 && t < (len - 1))
GUI.c (f:\stm32f1-demo\librrary\gui):                LCD_ShowChar(x + (size / 2)*t, y, POINT_COLOR, BACK_COLOR, ' ', size, 1);
GUI.c (f:\stm32f1-demo\librrary\gui):            else enshow = 1;
GUI.c (f:\stm32f1-demo\librrary\gui):        LCD_ShowChar(x + (size / 2)*t, y, POINT_COLOR, BACK_COLOR, temp + '0', size, 1);
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式   0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):        if((tfont16[k].Index[0] == *(s)) && (tfont16[k].Index[1] == *(s + 1)))
GUI.c (f:\stm32f1-demo\librrary\gui):            Lcd_SetRegion(x, y, x + 16 - 1, y + 16 - 1);
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1); //恢复窗口为全屏
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式   0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):        if((tfont24[k].Index[0] == *(s)) && (tfont24[k].Index[1] == *(s + 1)))
GUI.c (f:\stm32f1-demo\librrary\gui):            Lcd_SetRegion(x, y, x + 24 - 1, y + 24 - 1);
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1); //恢复窗口为全屏
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式   0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):        if((tfont32[k].Index[0] == *(s)) && (tfont32[k].Index[1] == *(s + 1)))
GUI.c (f:\stm32f1-demo\librrary\gui):            Lcd_SetRegion(x, y, x + 32 - 1, y + 32 - 1);
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1); //恢复窗口为全屏
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式   0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):            if(*str > 0x80)bHz = 1; //中文
GUI.c (f:\stm32f1-demo\librrary\gui)://          mode:模式   0,填充模式;1,叠加模式
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(x, y, x + 40 - 1, y + 40 - 1); //窗口设置
GUI.c (f:\stm32f1-demo\librrary\gui):        picH = *(p + i * 2 + 1);
GUI.c (f:\stm32f1-demo\librrary\gui):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1); //恢复显示窗口为全屏
Hw_config.c (f:\stm32f1-demo\stm32_usb-driver\src):        pbuf[ 2 * idx + 1] = 0;
Hw_config.c (f:\stm32f1-demo\stm32_usb-driver\src):    MAL_Init(1);
Iic.c (f:\stm32f1-demo\drivers\iic):        SendByte <<= 1;
Iic.c (f:\stm32f1-demo\drivers\iic):        ReceiveByte <<= 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    I2C_SendByte(SlaveAddress + 1);
Iic.c (f:\stm32f1-demo\drivers\iic):    I2C_SendByte(SlaveAddress + 1);
Iic.c (f:\stm32f1-demo\drivers\iic):        if(Renum == 1)
Iic.c (f:\stm32f1-demo\drivers\iic):        if(Renum == 1)
Iic.c (f:\stm32f1-demo\drivers\iic):    return 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    return 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    addr = addr_ << 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    writing = 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    busy = 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    addr = addr_ << 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    reading = 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    busy = 1;
Iic.c (f:\stm32f1-demo\drivers\iic):    static int8_t index;                                                 //index is signed -1==send the subaddress
Iic.c (f:\stm32f1-demo\drivers\iic):            subaddress_sent = 1;                                         //make sure this is set in case of no subaddress, so following code runs correctly
Iic.c (f:\stm32f1-demo\drivers\iic):                index = -1;                                              //send a subaddress
Iic.c (f:\stm32f1-demo\drivers\iic):        if(bytes == 1 && reading && subaddress_sent)                     //we are receiving 1 byte - EV6_3
Iic.c (f:\stm32f1-demo\drivers\iic):            final_stop = 1;
Iic.c (f:\stm32f1-demo\drivers\iic):        final_stop = 1;
Iic.c (f:\stm32f1-demo\drivers\iic):                final_stop = 1;                                          //required to fix hardware
Iic.c (f:\stm32f1-demo\drivers\iic):                read_p[index++] = I2C_ReceiveData(I2Cx);                 //read data N-1
Iic.c (f:\stm32f1-demo\drivers\iic):                read_p[index++] = I2C_ReceiveData(I2Cx);                 //read data N-1
Iic.c (f:\stm32f1-demo\drivers\iic):                subaddress_sent = 1;                                     //this is set back to zero upon completion of the current task
Iic.c (f:\stm32f1-demo\drivers\iic):        if(index != -1)
Iic.c (f:\stm32f1-demo\drivers\iic):    if(index == bytes + 1)                                               //we have completed the current job
Init.c (f:\stm32f1-demo\drivers\init):    IWDG_SetReload(0x1F4);       //40KHz内部时钟 (1/40000 * 64 * 0x1F4 = 0.8s)
Init.c (f:\stm32f1-demo\drivers\init):    __set_FAULTMASK(1);
JLinkSettings.ini (f:\stm32f1-demo\prj):ShowInfoWin = 1
JLinkSettings.ini (f:\stm32f1-demo\prj):AllowSimulation = 1
JLinkSettings.ini (f:\stm32f1-demo\prj):SkipProgOnCRCMatch = 1
JLinkSettings.ini (f:\stm32f1-demo\prj):VerifyDownload = 1
JLinkSettings.ini (f:\stm32f1-demo\prj):AllowCaching = 1
Lcd_Driver.c (f:\stm32f1-demo\modules\lcd_oled):创建时间: 2018-1-05 by zam
Lcd_Driver.c (f:\stm32f1-demo\modules\lcd_oled):#if USE_HORIZONTAL==1	//使用横屏	  
Lcd_Driver.c (f:\stm32f1-demo\modules\lcd_oled):    lcddev.dir = 1; //横屏
Lcd_Driver.c (f:\stm32f1-demo\modules\lcd_oled):#if USE_HORIZONTAL==1	//使用横屏
Lcd_Driver.c (f:\stm32f1-demo\modules\lcd_oled):    Lcd_SetRegion(x, y, x + 1, y + 1);
Lcd_Driver.c (f:\stm32f1-demo\modules\lcd_oled):    Lcd_SetRegion(0, 0, lcddev.width - 1, lcddev.height - 1);
Lcd_Driver.h (f:\stm32f1-demo\modules):#define USE_HORIZONTAL  	0	//定义是否使用横屏 		0,不使用.1,使用.
Lcd_Driver.h (f:\stm32f1-demo\modules):#if USE_HORIZONTAL==1	//使用横屏
Led.c (f:\stm32f1-demo\modules\led):创建时间: 2018-1-05 by zam
Led.c (f:\stm32f1-demo\modules\led):创建时间: 2018-1-05 by zam
Led.c (f:\stm32f1-demo\modules\led):创建时间: 2018-1-05 by zam
Led.c (f:\stm32f1-demo\modules\led):创建时间: 2018-1-05 by zam
Led.h (f:\stm32f1-demo\modules):	LED_1=1,
Lowpassfilter2p.c (f:\stm32f1-demo\librrary\lowpassfilter2p):	c=1.0+2.0*cosf(_M_PI_F/4.0f)*ohm+ohm*ohm;
Lowpassfilter2p.c (f:\stm32f1-demo\librrary\lowpassfilter2p):	lowpassfilter_date._a1=2.0f*(ohm*ohm-1.0f)/c;
Lowpassfilter2p.c (f:\stm32f1-demo\librrary\lowpassfilter2p):	lowpassfilter_date._a2=(1.0f-2.0f*cosf(_M_PI_F/4.0f)*ohm+ohm*ohm)/c;
Lseek.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The fast seek function is enabled when the member <tt>cltbl</tt> in the file object is not NULL. The CLMT must be created into the <tt>DWORD</tt> array prior to use the fast seek function. To create the CLMT, set address of the <tt>DWORD</tt> array to the member <tt>cltbl</tt> in the open file object, set the size of array in unit of items to the first item and call the <tt>f_lseek</tt> function with <tt class="arg">ofs</tt><tt> = CREATE_LINKMAP</tt>. After the function succeeded and CLMT is created, no FAT access is occured in subsequent <tt>f_read</tt>, <tt>f_write</tt>, <tt>f_lseek</tt> function to the file. The number of items used or required is returned into the first item of the array. The number of items to be used is (number of the file fragments + 1) * 2. For example, when the file is fragmented in 5, 12 items in the array will be used. If the function failed with <tt>FR_NOT_ENOUGH_CORE</tt>, the given array size is insufficient for the file.</p>
Lseek.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_minimize">FF_FS_MINIMIZE</a> &lt;= 2</tt>. To use fast seek function, <tt><a href="config.html#use_fastseek">FF_USE_FASTSEEK</a></tt> needs to be set 1.</p>
Main.c (f:\stm32f1-demo\main):    Gui_StrCenter(0, 10, BLUE, YELLOW, "Mcudev", 16, 1); //居中显示
Main.c (f:\stm32f1-demo\main):    Gui_StrCenter(0, 28, RED, BLUE, "Temp:32℃", 16, 1); //居中显示
Main.c (f:\stm32f1-demo\main):    Gui_StrCenter(0, 46, YELLOW, BLUE, "Hum:20%", 16, 1); //居中显示
Main.c (f:\stm32f1-demo\main):    Gui_StrCenter(0, 64, WHITE, BLUE, "VOL:3.2V", 16, 1); //居中显示
Main.c (f:\stm32f1-demo\main):    Gui_StrCenter(0, 82, GREEN, BLUE, "I:1.25mA", 16, 1); //居中显示
Main.c (f:\stm32f1-demo\main):    Gui_StrCenter(0, 100, RED, BLUE, "12:20AM", 16, 1); //居中显示
Main.c (f:\stm32f1-demo\main):    while(1)
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):    case 1:
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):    Status = SD_WriteMultiBlocks((uint8_t*)Writebuff, Memory_Offset, Transfer_Length,1);
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):    case 1:
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):      SD_ReadMultiBlocks((uint8_t*)Readbuff, Memory_Offset, Transfer_Length, 1);
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):    case 1:
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):        Mass_Block_Count[0] = (mSDCardInfo.SD_csd.DeviceSize + 1) * 1024;
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):        NumberOfBlocks  = ((1 << (mSDCardInfo.SD_csd.RdBlockLen)) / 512);
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):        Mass_Block_Count[0] = ((mSDCardInfo.SD_csd.DeviceSize + 1) * (1 << DeviceSizeMul) << (NumberOfBlocks/2));
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):    temp_block_mul = (1 << SD_csd.RdBlockLen)/ 512;
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):    Mass_Block_Count[0] = ((SD_csd.DeviceSize + 1) * (1 << (DeviceSizeMul))) * temp_block_mul;
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):      Mass_Block_Count[1] = NAND_ZONE_SIZE * NAND_BLOCK_SIZE * NAND_MAX_ZONE ;
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):      Mass_Block_Size[1]  = NAND_PAGE_SIZE;
Mass_mal.c (f:\stm32f1-demo\stm32_usb-driver\src):      Mass_Memory_Size[1] = (Mass_Block_Count[1] * Mass_Block_Size[1]);
Mass_mal.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define MAL_FAIL 1
Mass_mal.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define MAX_LUN  1
Math_stm.c (f:\stm32f1-demo\librrary\math):功能描述： 快速开平方求倒    1/sqrt(x*x)
Math_stm.c (f:\stm32f1-demo\librrary\math):创建时间: 2018-1-05 by zam
Math_stm.c (f:\stm32f1-demo\librrary\math):	i = 0x5f3759df - (i>>1);
Math_stm.c (f:\stm32f1-demo\librrary\math):	y = y * (1.5f - (halfx * y * y));
Math_stm.c (f:\stm32f1-demo\librrary\math):	i = 0x5f375a86 - (i >> 1);
Math_stm.c (f:\stm32f1-demo\librrary\math):	y = y * (1.5F - (x2 * y * y));
Mavlink.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_ALIGNED_FIELDS 1
Mavlink.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_CRC_EXTRA 1
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):#define M_PI_2 ((float)asin(1))
Mavlink_conversions.h (f:\stm32f1-demo\mavlink): * @param quaternion a [w, x, y, z] ordered quaternion (null-rotation being 1 0 0 0)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    double b = quaternion[1];
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[0][1] = 2 * (b * c - a * d);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[1][0] = 2 * (b * c + a * d);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[1][1] = aSq - bSq + cSq - dSq;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[1][2] = 2 * (c * d - a * b);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[2][1] = 2 * (a * b + c * d);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    if(fabsf(theta - (float)M_PI_2) < 1.0e-3f)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        psi = (atan2f(dcm[1][2] - dcm[0][1],
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):                      dcm[0][2] + dcm[1][1]) + phi);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    else if(fabsf(theta + (float)M_PI_2) < 1.0e-3f)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        psi = atan2f(dcm[1][2] - dcm[0][1],
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):                     dcm[0][2] + dcm[1][1] - phi);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        phi = atan2f(dcm[2][1], dcm[2][2]);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        psi = atan2f(dcm[1][0], dcm[0][0]);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink): * @param quaternion a [w, x, y, z] ordered quaternion (null-rotation being 1 0 0 0)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink): * @param quaternion a [w, x, y, z] ordered quaternion (null-rotation being 1 0 0 0)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    quaternion[1] = (sinPhi_2 * cosTheta_2 * cosPsi_2 -
Mavlink_conversions.h (f:\stm32f1-demo\mavlink): * @param quaternion a [w, x, y, z] ordered quaternion (null-rotation being 1 0 0 0)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    float tr = dcm[0][0] + dcm[1][1] + dcm[2][2];
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        float s = sqrtf(tr + 1.0f);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[1] = (dcm[2][1] - dcm[1][2]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[3] = (dcm[1][0] - dcm[0][1]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        for(i = 1; i < 3; i++)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        dcm_j = (dcm_i + 1) % 3;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):                   dcm[dcm_k][dcm_k]) + 1.0f);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[dcm_i + 1] = s * 0.5f;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[dcm_j + 1] = (dcm[dcm_i][dcm_j] + dcm[dcm_j][dcm_i]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[dcm_k + 1] = (dcm[dcm_k][dcm_i] + dcm[dcm_i][dcm_k]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    float tr = dcm[0][0] + dcm[1][1] + dcm[2][2];
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        float s = sqrtf(tr + 1.0f);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[1] = (dcm[2][1] - dcm[1][2]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[3] = (dcm[1][0] - dcm[0][1]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        for(i = 1; i < 3; i++)
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        int dcm_j = (dcm_i + 1) % 3;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):                         dcm[dcm_k][dcm_k]) + 1.0f);
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[dcm_i + 1] = s * 0.5f;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[dcm_j + 1] = (dcm[dcm_i][dcm_j] + dcm[dcm_j][dcm_i]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):        quaternion[dcm_k + 1] = (dcm[dcm_k][dcm_i] + dcm[dcm_i][dcm_k]) * s;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[0][1] = -cosPhi * sinPsi + sinPhi * sinThe * cosPsi;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[1][0] = cosThe * sinPsi;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[1][1] = cosPhi * cosPsi + sinPhi * sinThe * sinPsi;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[1][2] = -sinPhi * cosPsi + cosPhi * sinThe * sinPsi;
Mavlink_conversions.h (f:\stm32f1-demo\mavlink):    dcm[2][1] = sinPhi * cosThe;
Mavlink_cpu.h (f:\stm32f1-demo\mavlink):    1,
Mavlink_cpu.h (f:\stm32f1-demo\mavlink):    1
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * @param system_id Id of the sending (this) system, 1-127
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	mavlink_get_channel_status(chan)->current_tx_seq = mavlink_get_channel_status(chan)->current_tx_seq+1;
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	buf[1] = length;
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	checksum = crc_calculate((const uint8_t*)&buf[1], MAVLINK_CORE_HEADER_LEN);
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	ck[1] = (uint8_t)(checksum >> 8);
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	ck[1] = (uint8_t)(msg->checksum >> 8);
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):		ck[1] = (uint8_t)(msg->checksum >> 8);
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	ck[1] = (uint8_t)(msg->checksum >> 8);
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * @return 0 if no message could be decoded, 1 on good message and CRC, 2 on bad CRC
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):                _MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx+1] = (char)c;
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	r_mavlink_status->current_rx_seq = status->current_rx_seq+1;
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):		r_message->checksum = _MAV_PAYLOAD(rxmsg)[status->packet_idx] | (_MAV_PAYLOAD(rxmsg)[status->packet_idx+1]<<8);
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * it could be successfully decoded. This function will return 0, 1 or
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * @return 0 if no message could be decoded, 1 on good message and CRC, 2 on bad CRC
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * it could be successfully decoded. This function will return 0 or 1.
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * @return 0 if no message could be decoded or bad CRC, 1 on good message and CRC
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * @brief Put a bitfield of length 1-32 bit into the buffer
Mavlink_helpers.h (f:\stm32f1-demo\mavlink): * @param bits number of bits to use to encode b, e.g. 1 for boolean, 2, 3, etc.
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	bout.b[1] = bin.b[2];
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	bout.b[2] = bin.b[1];
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	// 00001111 = 2^0 + 2^1 + 2^2 + 2^3 = 2^n - 1
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):	// = ((uint32_t)(1 << n)) - 1; // = 2^n - 1
Mavlink_helpers.h (f:\stm32f1-demo\mavlink):// to send 1 byte at a time, or MAVLINK_SEND_UART_BYTES() to send a
Mavlink_msg_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): float controls[8]; /*< Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.*/
Mavlink_msg_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @param controls Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @param controls Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @param controls Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @return Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_attitude_quaternion.h (f:\stm32f1-demo\mavlink\common): float q1; /*< Quaternion component 1, w (1 in null-rotation)*/
Mavlink_msg_attitude_quaternion.h (f:\stm32f1-demo\mavlink\common): * @param q1 Quaternion component 1, w (1 in null-rotation)
Mavlink_msg_attitude_quaternion.h (f:\stm32f1-demo\mavlink\common): * @param q1 Quaternion component 1, w (1 in null-rotation)
Mavlink_msg_attitude_quaternion.h (f:\stm32f1-demo\mavlink\common): * @param q1 Quaternion component 1, w (1 in null-rotation)
Mavlink_msg_attitude_quaternion.h (f:\stm32f1-demo\mavlink\common): * @return Quaternion component 1, w (1 in null-rotation)
Mavlink_msg_attitude_quaternion_cov.h (f:\stm32f1-demo\mavlink\common): float q[4]; /*< Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)*/
Mavlink_msg_attitude_quaternion_cov.h (f:\stm32f1-demo\mavlink\common): * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
Mavlink_msg_attitude_quaternion_cov.h (f:\stm32f1-demo\mavlink\common): * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
Mavlink_msg_attitude_quaternion_cov.h (f:\stm32f1-demo\mavlink\common): * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
Mavlink_msg_attitude_quaternion_cov.h (f:\stm32f1-demo\mavlink\common): * @return Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): float q[4]; /*< Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)*/
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): float thrust; /*< Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)*/
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): uint8_t type_mask; /*< Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude*/
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @return Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @return Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @return Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_att_pos_mocap.h (f:\stm32f1-demo\mavlink\common): float q[4]; /*< Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)*/
Mavlink_msg_att_pos_mocap.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_att_pos_mocap.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_att_pos_mocap.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_att_pos_mocap.h (f:\stm32f1-demo\mavlink\common): * @return Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_auth_key.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_auth_key.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): int32_t current_consumed; /*< Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate*/
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): int32_t energy_consumed; /*< Consumed energy, in HectoJoules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate*/
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): uint16_t voltages[10]; /*< Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.*/
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): int16_t current_battery; /*< Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current*/
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): int8_t battery_remaining; /*< Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery*/
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param current_consumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param energy_consumed Consumed energy, in HectoJoules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param current_consumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param energy_consumed Consumed energy, in HectoJoules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param current_consumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param energy_consumed Consumed energy, in HectoJoules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @return Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @return Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @return Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @return Consumed energy, in HectoJoules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
Mavlink_msg_battery_status.h (f:\stm32f1-demo\mavlink\common): * @return Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): uint8_t control_request; /*< 0: request control of this MAV, 1: Release control of this MAV*/
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): uint8_t version; /*< 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.*/
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):         { "control_request", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_change_operator_control_t, control_request) }, \
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):         { "control_request", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_change_operator_control_t, control_request) }, \
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @param control_request 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @param version 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @param control_request 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @param version 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @param control_request 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @param version 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @return 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_change_operator_control.h (f:\stm32f1-demo\mavlink\common): * @return 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): uint8_t control_request; /*< 0: request control of this MAV, 1: Release control of this MAV*/
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): uint8_t ack; /*< 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control*/
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):         { "control_request", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_change_operator_control_ack_t, control_request) }, \
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):         { "control_request", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_change_operator_control_ack_t, control_request) }, \
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @param control_request 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @param ack 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @param control_request 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @param ack 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @param control_request 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @param ack 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, control_request);
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @return 0: request control of this MAV, 1: Release control of this MAV
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_change_operator_control_ack.h (f:\stm32f1-demo\mavlink\common): * @return 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
Mavlink_msg_command_int.h (f:\stm32f1-demo\mavlink\common): uint8_t current; /*< false:0, true:1*/
Mavlink_msg_command_int.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_command_int.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_command_int.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_command_int.h (f:\stm32f1-demo\mavlink\common): * @return false:0, true:1
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): float param1; /*< Parameter 1, as defined by MAV_CMD enum.*/
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): uint8_t confirmation; /*< 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)*/
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @param confirmation 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @param param1 Parameter 1, as defined by MAV_CMD enum.
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @param confirmation 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @param param1 Parameter 1, as defined by MAV_CMD enum.
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @param confirmation 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @param param1 Parameter 1, as defined by MAV_CMD enum.
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @return 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
Mavlink_msg_command_long.h (f:\stm32f1-demo\mavlink\common): * @return Parameter 1, as defined by MAV_CMD enum.
Mavlink_msg_control_system_state.h (f:\stm32f1-demo\mavlink\common): float airspeed; /*< Airspeed, set to -1 if unknown*/
Mavlink_msg_control_system_state.h (f:\stm32f1-demo\mavlink\common): * @param airspeed Airspeed, set to -1 if unknown
Mavlink_msg_control_system_state.h (f:\stm32f1-demo\mavlink\common): * @param airspeed Airspeed, set to -1 if unknown
Mavlink_msg_control_system_state.h (f:\stm32f1-demo\mavlink\common): * @param airspeed Airspeed, set to -1 if unknown
Mavlink_msg_control_system_state.h (f:\stm32f1-demo\mavlink\common): * @return Airspeed, set to -1 if unknown
Mavlink_msg_data_stream.h (f:\stm32f1-demo\mavlink\common): uint8_t on_off; /*< 1 stream is enabled, 0 stream is stopped.*/
Mavlink_msg_data_stream.h (f:\stm32f1-demo\mavlink\common): * @param on_off 1 stream is enabled, 0 stream is stopped.
Mavlink_msg_data_stream.h (f:\stm32f1-demo\mavlink\common): * @param on_off 1 stream is enabled, 0 stream is stopped.
Mavlink_msg_data_stream.h (f:\stm32f1-demo\mavlink\common): * @param on_off 1 stream is enabled, 0 stream is stopped.
Mavlink_msg_data_stream.h (f:\stm32f1-demo\mavlink\common): * @return 1 stream is enabled, 0 stream is stopped.
Mavlink_msg_data_transmission_handshake.h (f:\stm32f1-demo\mavlink\common): uint8_t jpg_quality; /*< JPEG quality out of [1,100]*/
Mavlink_msg_data_transmission_handshake.h (f:\stm32f1-demo\mavlink\common): * @param jpg_quality JPEG quality out of [1,100]
Mavlink_msg_data_transmission_handshake.h (f:\stm32f1-demo\mavlink\common): * @param jpg_quality JPEG quality out of [1,100]
Mavlink_msg_data_transmission_handshake.h (f:\stm32f1-demo\mavlink\common): * @param jpg_quality JPEG quality out of [1,100]
Mavlink_msg_data_transmission_handshake.h (f:\stm32f1-demo\mavlink\common): * @return JPEG quality out of [1,100]
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): float pos_horiz_accuracy; /*< Horizontal position 1-STD accuracy relative to the EKF local origin (m)*/
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): float pos_vert_accuracy; /*< Vertical position 1-STD accuracy relative to the EKF local origin (m)*/
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @param pos_horiz_accuracy Horizontal position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @param pos_vert_accuracy Vertical position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @param pos_horiz_accuracy Horizontal position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @param pos_vert_accuracy Vertical position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @param pos_horiz_accuracy Horizontal position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @param pos_vert_accuracy Vertical position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @return Horizontal position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_estimator_status.h (f:\stm32f1-demo\mavlink\common): * @return Vertical position 1-STD accuracy relative to the EKF local origin (m)
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):         { "landed_state", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_extended_sys_state_t, landed_state) }, \
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):         { "landed_state", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_extended_sys_state_t, landed_state) }, \
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, landed_state);
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, landed_state);
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, landed_state);
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, landed_state);
Mavlink_msg_extended_sys_state.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_file_transfer_protocol_t, target_system) }, \
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):         { "target_system", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_file_transfer_protocol_t, target_system) }, \
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_system);
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_system);
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_system);
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_system);
Mavlink_msg_file_transfer_protocol.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): float attitude_q[4]; /*< (1 0 0 0 for unknown)*/
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): uint8_t est_capabilities; /*< bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)*/
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @param est_capabilities bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @param attitude_q (1 0 0 0 for unknown)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @param est_capabilities bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @param attitude_q (1 0 0 0 for unknown)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @param est_capabilities bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @param attitude_q (1 0 0 0 for unknown)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @return bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
Mavlink_msg_follow_target.h (f:\stm32f1-demo\mavlink\common): * @return (1 0 0 0 for unknown)
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_gps_inject_data_t, target_component) }, \
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_gps_inject_data_t, target_component) }, \
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_gps_inject_data.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_gps_input.h (f:\stm32f1-demo\mavlink\common): uint8_t fix_type; /*< 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK*/
Mavlink_msg_gps_input.h (f:\stm32f1-demo\mavlink\common): * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
Mavlink_msg_gps_input.h (f:\stm32f1-demo\mavlink\common): * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
Mavlink_msg_gps_input.h (f:\stm32f1-demo\mavlink\common): * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
Mavlink_msg_gps_input.h (f:\stm32f1-demo\mavlink\common): * @return 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common): uint8_t flags; /*< LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.*/
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):         { "len", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_gps_rtcm_data_t, len) }, \
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):         { "len", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_gps_rtcm_data_t, len) }, \
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common): * @param flags LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, len);
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common): * @param flags LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, len);
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common): * @param flags LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, len);
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, len);
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common): * @return LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
Mavlink_msg_gps_rtcm_data.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common): uint8_t satellite_used[20]; /*< 0: Satellite not used, 1: used for localization*/
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):         { "satellite_prn", NULL, MAVLINK_TYPE_UINT8_T, 20, 1, offsetof(mavlink_gps_status_t, satellite_prn) }, \
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):         { "satellite_prn", NULL, MAVLINK_TYPE_UINT8_T, 20, 1, offsetof(mavlink_gps_status_t, satellite_prn) }, \
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common): * @param satellite_used 0: Satellite not used, 1: used for localization
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common): * @param satellite_used 0: Satellite not used, 1: used for localization
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common): * @param satellite_used 0: Satellite not used, 1: used for localization
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t_array(buf, 1, satellite_prn, 20);
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t_array(msg, satellite_prn, 20,  1);
Mavlink_msg_gps_status.h (f:\stm32f1-demo\mavlink\common): * @return 0: Satellite not used, 1: used for localization
Mavlink_msg_high_latency.h (f:\stm32f1-demo\mavlink\common): uint8_t failsafe; /*< failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)*/
Mavlink_msg_high_latency.h (f:\stm32f1-demo\mavlink\common): * @param failsafe failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
Mavlink_msg_high_latency.h (f:\stm32f1-demo\mavlink\common): * @param failsafe failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
Mavlink_msg_high_latency.h (f:\stm32f1-demo\mavlink\common): * @param failsafe failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
Mavlink_msg_high_latency.h (f:\stm32f1-demo\mavlink\common): * @return failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
Mavlink_msg_high_latency2.h (f:\stm32f1-demo\mavlink\common): int8_t battery; /*< Battery (percentage, -1 for DNU)*/
Mavlink_msg_high_latency2.h (f:\stm32f1-demo\mavlink\common): * @param battery Battery (percentage, -1 for DNU)
Mavlink_msg_high_latency2.h (f:\stm32f1-demo\mavlink\common): * @param battery Battery (percentage, -1 for DNU)
Mavlink_msg_high_latency2.h (f:\stm32f1-demo\mavlink\common): * @param battery Battery (percentage, -1 for DNU)
Mavlink_msg_high_latency2.h (f:\stm32f1-demo\mavlink\common): * @return Battery (percentage, -1 for DNU)
Mavlink_msg_hil_actuator_controls.h (f:\stm32f1-demo\mavlink\common): float controls[16]; /*< Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.*/
Mavlink_msg_hil_actuator_controls.h (f:\stm32f1-demo\mavlink\common): * @param controls Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
Mavlink_msg_hil_actuator_controls.h (f:\stm32f1-demo\mavlink\common): * @param controls Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
Mavlink_msg_hil_actuator_controls.h (f:\stm32f1-demo\mavlink\common): * @param controls Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
Mavlink_msg_hil_actuator_controls.h (f:\stm32f1-demo\mavlink\common): * @return Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float roll_ailerons; /*< Control output -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float pitch_elevator; /*< Control output -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float yaw_rudder; /*< Control output -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float throttle; /*< Throttle 0 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float aux1; /*< Aux 1, -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float aux2; /*< Aux 2, -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float aux3; /*< Aux 3, -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): float aux4; /*< Aux 4, -1 .. 1*/
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param roll_ailerons Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param pitch_elevator Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param yaw_rudder Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param throttle Throttle 0 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux1 Aux 1, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux2 Aux 2, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux3 Aux 3, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux4 Aux 4, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param roll_ailerons Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param pitch_elevator Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param yaw_rudder Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param throttle Throttle 0 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux1 Aux 1, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux2 Aux 2, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux3 Aux 3, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux4 Aux 4, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param roll_ailerons Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param pitch_elevator Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param yaw_rudder Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param throttle Throttle 0 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux1 Aux 1, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux2 Aux 2, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux3 Aux 3, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @param aux4 Aux 4, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Control output -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Throttle 0 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Aux 1, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Aux 2, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Aux 3, -1 .. 1
Mavlink_msg_hil_controls.h (f:\stm32f1-demo\mavlink\common): * @return Aux 4, -1 .. 1
Mavlink_msg_hil_gps.h (f:\stm32f1-demo\mavlink\common): uint8_t fix_type; /*< 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.*/
Mavlink_msg_hil_gps.h (f:\stm32f1-demo\mavlink\common): * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
Mavlink_msg_hil_gps.h (f:\stm32f1-demo\mavlink\common): * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
Mavlink_msg_hil_gps.h (f:\stm32f1-demo\mavlink\common): * @param fix_type 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
Mavlink_msg_hil_gps.h (f:\stm32f1-demo\mavlink\common): * @return 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
Mavlink_msg_hil_rc_inputs_raw.h (f:\stm32f1-demo\mavlink\common): uint16_t chan1_raw; /*< RC channel 1 value, in microseconds*/
Mavlink_msg_hil_rc_inputs_raw.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds
Mavlink_msg_hil_rc_inputs_raw.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds
Mavlink_msg_hil_rc_inputs_raw.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds
Mavlink_msg_hil_rc_inputs_raw.h (f:\stm32f1-demo\mavlink\common): * @return RC channel 1 value, in microseconds
Mavlink_msg_hil_state_quaternion.h (f:\stm32f1-demo\mavlink\common): float attitude_quaternion[4]; /*< Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)*/
Mavlink_msg_hil_state_quaternion.h (f:\stm32f1-demo\mavlink\common): * @param attitude_quaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
Mavlink_msg_hil_state_quaternion.h (f:\stm32f1-demo\mavlink\common): * @param attitude_quaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
Mavlink_msg_hil_state_quaternion.h (f:\stm32f1-demo\mavlink\common): * @param attitude_quaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
Mavlink_msg_hil_state_quaternion.h (f:\stm32f1-demo\mavlink\common): * @return Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_log_erase_t, target_component) }, \
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_log_erase_t, target_component) }, \
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_erase.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_log_request_end_t, target_component) }, \
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_log_request_end_t, target_component) }, \
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_log_request_end.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_manual_control.h (f:\stm32f1-demo\mavlink\common): uint16_t buttons; /*< A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.*/
Mavlink_msg_manual_control.h (f:\stm32f1-demo\mavlink\common): * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
Mavlink_msg_manual_control.h (f:\stm32f1-demo\mavlink\common): * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
Mavlink_msg_manual_control.h (f:\stm32f1-demo\mavlink\common): * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
Mavlink_msg_manual_control.h (f:\stm32f1-demo\mavlink\common): * @return A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
Mavlink_msg_manual_setpoint.h (f:\stm32f1-demo\mavlink\common): float thrust; /*< Collective thrust, normalized to 0 .. 1*/
Mavlink_msg_manual_setpoint.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1
Mavlink_msg_manual_setpoint.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1
Mavlink_msg_manual_setpoint.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1
Mavlink_msg_manual_setpoint.h (f:\stm32f1-demo\mavlink\common): * @return Collective thrust, normalized to 0 .. 1
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): uint8_t ver; /*< Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below*/
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): uint8_t type; /*< Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14*/
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @param ver Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @param type Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @param ver Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @param type Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @param ver Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @param type Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @return Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
Mavlink_msg_memory_vect.h (f:\stm32f1-demo\mavlink\common): * @return Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
Mavlink_msg_message_interval.h (f:\stm32f1-demo\mavlink\common): int32_t interval_us; /*< The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.*/
Mavlink_msg_message_interval.h (f:\stm32f1-demo\mavlink\common): * @param interval_us The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
Mavlink_msg_message_interval.h (f:\stm32f1-demo\mavlink\common): * @param interval_us The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
Mavlink_msg_message_interval.h (f:\stm32f1-demo\mavlink\common): * @param interval_us The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
Mavlink_msg_message_interval.h (f:\stm32f1-demo\mavlink\common): * @return The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_mission_ack_t, target_component) }, \
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_mission_ack_t, target_component) }, \
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_ack.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_mission_clear_all_t, target_component) }, \
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_mission_clear_all_t, target_component) }, \
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_clear_all.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_mission_current.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_mission_current.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_mission_item.h (f:\stm32f1-demo\mavlink\common): uint8_t current; /*< false:0, true:1*/
Mavlink_msg_mission_item.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_mission_item.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_mission_item.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_mission_item.h (f:\stm32f1-demo\mavlink\common): * @return false:0, true:1
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): uint16_t seq; /*< Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).*/
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): uint8_t current; /*< false:0, true:1*/
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @param current false:0, true:1
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @return Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
Mavlink_msg_mission_item_int.h (f:\stm32f1-demo\mavlink\common): * @return false:0, true:1
Mavlink_msg_mission_item_reached.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_mission_item_reached.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_mission_request_list_t, target_component) }, \
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_mission_request_list_t, target_component) }, \
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_mission_request_list.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_mission_request_partial_list.h (f:\stm32f1-demo\mavlink\common): int16_t end_index; /*< End index, -1 by default (-1: send list to end). Else a valid index of the list*/
Mavlink_msg_mission_request_partial_list.h (f:\stm32f1-demo\mavlink\common): * @param end_index End index, -1 by default (-1: send list to end). Else a valid index of the list
Mavlink_msg_mission_request_partial_list.h (f:\stm32f1-demo\mavlink\common): * @param end_index End index, -1 by default (-1: send list to end). Else a valid index of the list
Mavlink_msg_mission_request_partial_list.h (f:\stm32f1-demo\mavlink\common): * @param end_index End index, -1 by default (-1: send list to end). Else a valid index of the list
Mavlink_msg_mission_request_partial_list.h (f:\stm32f1-demo\mavlink\common): * @return End index, -1 by default (-1: send list to end). Else a valid index of the list
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): float scale; /*< Scale, maps the RC range [-1, 1] to a parameter value*/
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): int16_t param_index; /*< Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.*/
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): char param_id[16]; /*< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string*/
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param scale Scale, maps the RC range [-1, 1] to a parameter value
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param scale Scale, maps the RC range [-1, 1] to a parameter value
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @param scale Scale, maps the RC range [-1, 1] to a parameter value
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @return Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
Mavlink_msg_param_map_rc.h (f:\stm32f1-demo\mavlink\common): * @return Scale, maps the RC range [-1, 1] to a parameter value
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_param_request_list_t, target_component) }, \
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):         { "target_component", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_param_request_list_t, target_component) }, \
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, target_component);
Mavlink_msg_param_request_list.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): int16_t param_index; /*< Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)*/
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): char param_id[16]; /*< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string*/
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @param param_index Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_request_read.h (f:\stm32f1-demo\mavlink\common): * @return Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
Mavlink_msg_param_set.h (f:\stm32f1-demo\mavlink\common): char param_id[16]; /*< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string*/
Mavlink_msg_param_set.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_set.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_set.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_set.h (f:\stm32f1-demo\mavlink\common): * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_value.h (f:\stm32f1-demo\mavlink\common): char param_id[16]; /*< Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string*/
Mavlink_msg_param_value.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_value.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_value.h (f:\stm32f1-demo\mavlink\common): * @param param_id Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_param_value.h (f:\stm32f1-demo\mavlink\common): * @return Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
Mavlink_msg_ping.h (f:\stm32f1-demo\mavlink\common): uint64_t time_usec; /*< Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)*/
Mavlink_msg_ping.h (f:\stm32f1-demo\mavlink\common): * @param time_usec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
Mavlink_msg_ping.h (f:\stm32f1-demo\mavlink\common): * @param time_usec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
Mavlink_msg_ping.h (f:\stm32f1-demo\mavlink\common): * @param time_usec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
Mavlink_msg_ping.h (f:\stm32f1-demo\mavlink\common): * @return Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
Mavlink_msg_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): uint16_t type_mask; /*< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate*/
Mavlink_msg_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): uint16_t type_mask; /*< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate*/
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): uint8_t coordinate_frame; /*< Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9*/
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @return Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_raw_pressure.h (f:\stm32f1-demo\mavlink\common): int16_t press_diff1; /*< Differential pressure 1 (raw, 0 if nonexistant)*/
Mavlink_msg_raw_pressure.h (f:\stm32f1-demo\mavlink\common): * @param press_diff1 Differential pressure 1 (raw, 0 if nonexistant)
Mavlink_msg_raw_pressure.h (f:\stm32f1-demo\mavlink\common): * @param press_diff1 Differential pressure 1 (raw, 0 if nonexistant)
Mavlink_msg_raw_pressure.h (f:\stm32f1-demo\mavlink\common): * @param press_diff1 Differential pressure 1 (raw, 0 if nonexistant)
Mavlink_msg_raw_pressure.h (f:\stm32f1-demo\mavlink\common): * @return Differential pressure 1 (raw, 0 if nonexistant)
Mavlink_msg_rc_channels.h (f:\stm32f1-demo\mavlink\common): uint16_t chan1_raw; /*< RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.*/
Mavlink_msg_rc_channels.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels.h (f:\stm32f1-demo\mavlink\common): * @return RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels_override.h (f:\stm32f1-demo\mavlink\common): uint16_t chan1_raw; /*< RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.*/
Mavlink_msg_rc_channels_override.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
Mavlink_msg_rc_channels_override.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
Mavlink_msg_rc_channels_override.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
Mavlink_msg_rc_channels_override.h (f:\stm32f1-demo\mavlink\common): * @return RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): uint16_t chan1_raw; /*< RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.*/
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): uint8_t port; /*< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.*/
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_raw.h (f:\stm32f1-demo\mavlink\common): * @return RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): int16_t chan1_scaled; /*< RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.*/
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): uint8_t port; /*< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.*/
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @param chan1_scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
Mavlink_msg_rc_channels_scaled.h (f:\stm32f1-demo\mavlink\common): * @return RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
Mavlink_msg_request_data_stream.h (f:\stm32f1-demo\mavlink\common): uint8_t start_stop; /*< 1 to start sending, 0 to stop sending.*/
Mavlink_msg_request_data_stream.h (f:\stm32f1-demo\mavlink\common): * @param start_stop 1 to start sending, 0 to stop sending.
Mavlink_msg_request_data_stream.h (f:\stm32f1-demo\mavlink\common): * @param start_stop 1 to start sending, 0 to stop sending.
Mavlink_msg_request_data_stream.h (f:\stm32f1-demo\mavlink\common): * @param start_stop 1 to start sending, 0 to stop sending.
Mavlink_msg_request_data_stream.h (f:\stm32f1-demo\mavlink\common): * @return 1 to start sending, 0 to stop sending.
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): uint8_t uri_type; /*< The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary*/
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): uint8_t transfer_type; /*< The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.*/
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):         { "uri_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_resource_request_t, uri_type) }, \
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):         { "uri_type", NULL, MAVLINK_TYPE_UINT8_T, 0, 1, offsetof(mavlink_resource_request_t, uri_type) }, \
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @param uri_type The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @param transfer_type The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, uri_type);
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @param uri_type The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @param transfer_type The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, uri_type);
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @param uri_type The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @param transfer_type The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, uri_type);
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):    _mav_put_uint8_t(buf, 1, uri_type);
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @return The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_uint8_t(msg,  1);
Mavlink_msg_resource_request.h (f:\stm32f1-demo\mavlink\common): * @return The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): float p1x; /*< x position 1 / Latitude 1*/
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): float p1y; /*< y position 1 / Longitude 1*/
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): float p1z; /*< z position 1 / Altitude 1*/
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1x x position 1 / Latitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1y y position 1 / Longitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1z z position 1 / Altitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1x x position 1 / Latitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1y y position 1 / Longitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1z z position 1 / Altitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1x x position 1 / Latitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1y y position 1 / Longitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1z z position 1 / Altitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @return x position 1 / Latitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @return y position 1 / Longitude 1
Mavlink_msg_safety_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @return z position 1 / Altitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): float p1x; /*< x position 1 / Latitude 1*/
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): float p1y; /*< y position 1 / Longitude 1*/
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): float p1z; /*< z position 1 / Altitude 1*/
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1x x position 1 / Latitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1y y position 1 / Longitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1z z position 1 / Altitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1x x position 1 / Latitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1y y position 1 / Longitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1z z position 1 / Altitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1x x position 1 / Latitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1y y position 1 / Longitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @param p1z z position 1 / Altitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @return x position 1 / Latitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @return y position 1 / Longitude 1
Mavlink_msg_safety_set_allowed_area.h (f:\stm32f1-demo\mavlink\common): * @return z position 1 / Altitude 1
Mavlink_msg_scaled_pressure.h (f:\stm32f1-demo\mavlink\common): float press_diff; /*< Differential pressure 1 (hectopascal)*/
Mavlink_msg_scaled_pressure.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure.h (f:\stm32f1-demo\mavlink\common): * @return Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure2.h (f:\stm32f1-demo\mavlink\common): float press_diff; /*< Differential pressure 1 (hectopascal)*/
Mavlink_msg_scaled_pressure2.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure2.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure2.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure2.h (f:\stm32f1-demo\mavlink\common): * @return Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure3.h (f:\stm32f1-demo\mavlink\common): float press_diff; /*< Differential pressure 1 (hectopascal)*/
Mavlink_msg_scaled_pressure3.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure3.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure3.h (f:\stm32f1-demo\mavlink\common): * @param press_diff Differential pressure 1 (hectopascal)
Mavlink_msg_scaled_pressure3.h (f:\stm32f1-demo\mavlink\common): * @return Differential pressure 1 (hectopascal)
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): uint16_t servo1_raw; /*< Servo output 1 value, in microseconds*/
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): uint8_t port; /*< Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.*/
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @param servo1_raw Servo output 1 value, in microseconds
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @param servo1_raw Servo output 1 value, in microseconds
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @param servo1_raw Servo output 1 value, in microseconds
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @return Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
Mavlink_msg_servo_output_raw.h (f:\stm32f1-demo\mavlink\common): * @return Servo output 1 value, in microseconds
Mavlink_msg_set_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): float controls[8]; /*< Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.*/
Mavlink_msg_set_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @param controls Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_set_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @param controls Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_set_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @param controls Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_set_actuator_control_target.h (f:\stm32f1-demo\mavlink\common): * @return Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): float q[4]; /*< Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)*/
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): float thrust; /*< Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)*/
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): uint8_t type_mask; /*< Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude*/
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @return Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @return Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
Mavlink_msg_set_attitude_target.h (f:\stm32f1-demo\mavlink\common): * @return Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
Mavlink_msg_set_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): uint16_t type_mask; /*< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate*/
Mavlink_msg_set_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_global_int.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): uint16_t type_mask; /*< Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate*/
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): uint8_t coordinate_frame; /*< Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9*/
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param coordinate_frame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @param type_mask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @return Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
Mavlink_msg_set_position_target_local_ned.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
Mavlink_msg_sim_state.h (f:\stm32f1-demo\mavlink\common): float q1; /*< True attitude quaternion component 1, w (1 in null-rotation)*/
Mavlink_msg_sim_state.h (f:\stm32f1-demo\mavlink\common): * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
Mavlink_msg_sim_state.h (f:\stm32f1-demo\mavlink\common): * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
Mavlink_msg_sim_state.h (f:\stm32f1-demo\mavlink\common): * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
Mavlink_msg_sim_state.h (f:\stm32f1-demo\mavlink\common): * @return True attitude quaternion component 1, w (1 in null-rotation)
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):         { "text", NULL, MAVLINK_TYPE_CHAR, 50, 1, offsetof(mavlink_statustext_t, text) }, \
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):         { "text", NULL, MAVLINK_TYPE_CHAR, 50, 1, offsetof(mavlink_statustext_t, text) }, \
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):    _mav_put_char_array(buf, 1, text, 50);
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):    _mav_put_char_array(buf, 1, text, 50);
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):    _mav_put_char_array(buf, 1, text, 50);
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):    _mav_put_char_array(buf, 1, text, 50);
Mavlink_msg_statustext.h (f:\stm32f1-demo\mavlink\common):    return _MAV_RETURN_char_array(msg, text, 50,  1);
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_MSG_ID_SYS_STATUS 1
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): uint32_t onboard_control_sensors_present; /*< Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR*/
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): uint32_t onboard_control_sensors_enabled; /*< Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR*/
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): uint32_t onboard_control_sensors_health; /*< Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR*/
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): uint16_t voltage_battery; /*< Battery voltage, in millivolts (1 = 1 millivolt)*/
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): int16_t current_battery; /*< Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current*/
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): int8_t battery_remaining; /*< Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery*/
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common):    1, \
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @return Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @return Battery voltage, in millivolts (1 = 1 millivolt)
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @return Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
Mavlink_msg_sys_status.h (f:\stm32f1-demo\mavlink\common): * @return Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
Mavlink_msg_terrain_report.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_MSG_ID_TERRAIN_REPORT_CRC 1
Mavlink_msg_terrain_report.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_MSG_ID_136_CRC 1
Mavlink_msg_timesync.h (f:\stm32f1-demo\mavlink\common): int64_t tc1; /*< Time sync timestamp 1*/
Mavlink_msg_timesync.h (f:\stm32f1-demo\mavlink\common): * @param tc1 Time sync timestamp 1
Mavlink_msg_timesync.h (f:\stm32f1-demo\mavlink\common): * @param tc1 Time sync timestamp 1
Mavlink_msg_timesync.h (f:\stm32f1-demo\mavlink\common): * @param tc1 Time sync timestamp 1
Mavlink_msg_timesync.h (f:\stm32f1-demo\mavlink\common): * @return Time sync timestamp 1
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): float var_horiz; /*< Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.*/
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): float var_vert; /*< Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.*/
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): float horiz_accuracy; /*< Horizontal speed 1-STD accuracy*/
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): float vert_accuracy; /*< Vertical speed 1-STD accuracy*/
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param var_horiz Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param var_vert Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param horiz_accuracy Horizontal speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param vert_accuracy Vertical speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param var_horiz Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param var_vert Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param horiz_accuracy Horizontal speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param vert_accuracy Vertical speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param var_horiz Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param var_vert Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param horiz_accuracy Horizontal speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @param vert_accuracy Vertical speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @return Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @return Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @return Horizontal speed 1-STD accuracy
Mavlink_msg_wind_cov.h (f:\stm32f1-demo\mavlink\common): * @return Vertical speed 1-STD accuracy
Mavlink_types.h (f:\stm32f1-demo\mavlink):  //#define MAVPACKED( __Declaration__ ) __pragma( pack(push, 1) ) __Declaration__ __pragma( pack(pop) )
Mavlink_types.h (f:\stm32f1-demo\mavlink):#define MAVLINK_CORE_HEADER_LEN 5 ///< Length of core header (of the comm. layer): message length (1 byte) + message sequence (1 byte) + message system id (1 byte) + message component id (1 byte) + message type id (1 byte)
Mavlink_types.h (f:\stm32f1-demo\mavlink):#define MAVLINK_NUM_HEADER_BYTES (MAVLINK_CORE_HEADER_LEN + 1) ///< Length of all header bytes, including core and checksum
Mavlink_types.h (f:\stm32f1-demo\mavlink): * mavlink_param_union_double_t will be 8 bytes long, and treated as needing 8 byte alignment for the purposes of MAVLink 1.0 field ordering.
Mavlink_types.h (f:\stm32f1-demo\mavlink): * If is_double is 1 then the type is a double, and the remaining 63 bits are the double, with the lowest bit of the mantissa zero.
Mavlink_types.h (f:\stm32f1-demo\mavlink):        uint8_t is_double:1;
Mavlink_types.h (f:\stm32f1-demo\mavlink):	MAVLINK_TYPE_UINT8_T  = 1,
Mavlink_types.h (f:\stm32f1-demo\mavlink):#define mavlink_ck_b(msg) *(((msg)->len+(uint16_t)1) + (uint8_t *)_MAV_PAYLOAD_NON_CONST(msg))
Mavlink_types.h (f:\stm32f1-demo\mavlink):    MAVLINK_FRAMING_OK=1,
Mavlink_types.h (f:\stm32f1-demo\mavlink):#define MAVLINK_LITTLE_ENDIAN 1
Memory.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define TXFR_ONGOING  1
Messg_recive.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_recive.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_recive.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_recive.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_recive.c (f:\stm32f1-demo\librrary\messg_data):#if 1
Messg_recive.c (f:\stm32f1-demo\librrary\messg_data):                case 1:
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):创建时间: 2018-1-05 by zam
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):		buf[1]=(uint8_t)(length>>8);
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):		checksum=crc_calculate((const uint8_t*)&buf[1],6);
Messg_send.c (f:\stm32f1-demo\librrary\messg_data):		ck[1]=(uint8_t)(checksum>>8);
Messg_send.h (f:\stm32f1-demo\librrary): #define SYSID 1					//系统版本号
Messg_send.h (f:\stm32f1-demo\librrary): #define COMPID 1					//系统组件号
Misc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority
Misc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *                                1 bits for subpriority
Misc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority
Misc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority
Misc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                         |                                   |                             |   1 bits for subpriority
Misc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
Misc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                                            1 bits for subpriority */
Mkfs.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Specifies size of the allocation unit (cluter) in unit of byte. The valid value is <em>n</em> times the sector size. The <em>n</em> is power of 2 from 1 to 128 for FAT volume and upto 16MiB for exFAT volume. If zero is given, the default allocation unit size is selected depends on the volume size.</dd>
Mkfs.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When the logical drive to be formatted is bound to a specific partition (1-4) by support of multiple partition (<tt><a href="config.html#multi_partition">FF_MULTI_PARTITION</a> == 1</tt>), the FAT volume is created into the partition and <tt>FM_SFD</tt> flag is ignored. The physical drive needs to be partitioned with <tt>f_fdisk</tt> function or any other partitioning tools prior to create the FAT volume with this function.</p>
Mkfs.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_readonly">FF_FS_READOLNY</a> == 0</tt> and <tt><a href="config.html#use_mkfs">FF_USE_MKFS</a> == 1</tt>.</p>
Mount.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Mounting option. 0: Do not mount now (to be mounted on the first access to the volume), 1: Force mounted the volume to check if it is ready to work.</dd>
Mount.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>If the function with forced mounting (<tt>opt = 1</tt>) failed with <tt>FR_NOT_READY</tt>, it means that the filesystem object has been registered successfully but the volume is currently not ready to work. The volume mount process will be attempted on subsequent file/directroy function.</p>
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):float accConfidence      = 1.0f;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):        case 1: // Dot Front/Left/Top
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[0] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  0;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[4] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[3] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[0] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  0;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[4] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[3] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[3] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[0] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  0;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[4] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[3] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[0] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  0;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[4] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] = -1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[0] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[1] =  0;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[4] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            orientationMatrix[8] =  1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    magX = 1.0f;  // HJI mx * cosPitch + my * sinRoll * sinPitch + mz * cosRoll * sinPitch;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    static float accMagP = 1.0f;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    accConfidence = constrain(1.0f - (accConfidenceDecay * sqrt(fabs(accMag - 1.0f))), 0.0f, 1.0f);
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):        if(norm != 0.0f) //如果归一化后的模等于0 ，那么说明加速度数据或者传感器不正常，正常情况下 归一化后的结果恒等于 1.0 ，这是重点。
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            normR = 1.0f / norm; //加速度归一化
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):            normR = 1.0f / norm;//三轴磁场归一化
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):        normR = 1.0f / sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_PWR_MGMT_1, 1, &msg); // Device Reset
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_PWR_MGMT_1, 1, &msg); // Clock Source
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_PWR_MGMT_2, 1, &msg); // turn off all standby
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_SMPLRT_DIV, 1, &msg); // Accel Sample Rate 1000 Hz, Gyro Sample Rate 8000 Hz
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_CONFIG, 1, &msg); // Accel and Gyro DLPF Setting
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_ACCEL_CONFIG, 1, &msg); // Accel +/- 4 G Full Scale
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    I2cWriteBuffer(MPU6050_IIC, MPU6050_ADDRESS, MPU6050_GYRO_CONFIG, 1, &msg); // Gyro +/- 500 DPS Full Scale
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):////            return 1;
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Accel[YAXIS].bytes[1]       = I2C2_Buffer_Rx[ 0];//传输原始数据
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Accel[YAXIS].bytes[0]       = I2C2_Buffer_Rx[ 1];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Accel[XAXIS].bytes[1]       = I2C2_Buffer_Rx[ 2];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Accel[ZAXIS].bytes[1]       = I2C2_Buffer_Rx[ 4];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Tempreature.bytes[1] = I2C2_Buffer_Rx[ 6];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Gyro[PITCH].bytes[1]        = I2C2_Buffer_Rx[ 8];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Gyro[ROLL ].bytes[1]        = I2C2_Buffer_Rx[10];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    raw_date.Raw_Gyro[YAW  ].bytes[1]        = I2C2_Buffer_Rx[12];
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    //矩阵orientationMatrix * 矩阵straightAccelData ，矩阵orientationMatrix维度是3*3 ，矩阵straightAccelData维度是3*1
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    //结果放到矩阵rotatedAccelData ,矩阵维度是3*1
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    matrixMultiply(3, 3, 1, rotatedAccelData, orientationMatrix, straightAccelData);
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    //矩阵orientationMatrix * 矩阵straightGyroData ，矩阵orientationMatrix维度是3*3 ，矩阵straightGyroData维度是3*1
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    //结果放到矩阵rotatedGyroData ,矩阵维度是3*1
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    matrixMultiply(3, 3, 1, rotatedGyroData,  orientationMatrix, straightGyroData);
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    printf("ax=%d,ay=%d,az=%d\r\n", raw_date.Raw_Accel[0].value, raw_date.Raw_Accel[1].value, raw_date.Raw_Accel[2].value);
Mpu6050.c (f:\stm32f1-demo\modules\mpu6050):    printf("gx=%d,gy=%d,gz=%d\r\n", raw_date.Raw_Gyro[0].value, raw_date.Raw_Gyro[1].value, raw_date.Raw_Gyro[2].value);
Mpu6050.h (f:\stm32f1-demo\modules):#define ACCEL_SCALE_FACTOR 0.00119708f  // (1/8192) * 9.8065  (8192 LSB = 1 G)
Mpu6050.h (f:\stm32f1-demo\modules):#define GYRO_SCALE_FACTOR  0.00026646f  // (1/65.5) * pi/180   (65.5 LSB = 1 DPS)
Mpu9250.c (f:\stm32f1-demo\modules\mpu9250):创建时间: 2018-1-05 by zam
Mpu9250.c (f:\stm32f1-demo\modules\mpu9250):创建时间: 2018-1-05 by zam
Mpu9250.c (f:\stm32f1-demo\modules\mpu9250):创建时间: 2018-1-05 by zam
Mpu9250.c (f:\stm32f1-demo\modules\mpu9250):创建时间: 2018-1-05 by zam
Mpu9250.c (f:\stm32f1-demo\modules\mpu9250):创建时间: 2018-1-05 by zam
Mpu9250.h (f:\stm32f1-demo\modules):#define ACCEL_SCALE_FACTOR 0.00119708f  // (1/8192) * 9.8065  (8192 LSB = 1 G)
Mpu9250.h (f:\stm32f1-demo\modules):#define GYRO_SCALE_FACTOR  0.00026646f  // (1/65.5) * pi/180   (65.5 LSB = 1 DPS)
Ms5611.c (f:\stm32f1-demo\modules\ms5611):				buff_l=MS5611_Read_Reg(CMD_MS5611_PROM_READ+i*2+1);
Ms5611.c (f:\stm32f1-demo\modules\ms5611):	SENS=MS5611_PROM_BUFF[1]*pow(2.0,15.0)+dT*MS5611_PROM_BUFF[3]/pow(2.0,8.0); 
Ms5611.c (f:\stm32f1-demo\modules\ms5611):		SENS2 = 1.25*Aux;
Ms5611.c (f:\stm32f1-demo\modules\ms5611):创建时间: 2018-1-05 by zam
Ms5611.c (f:\stm32f1-demo\modules\ms5611):创建时间: 2018-1-05 by zam
Open.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Always available. Only <tt>FA_READ</tt> and <tt>FA_OPEN_EXISTING</tt> are available for the mode flags when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 1</tt>.</p>
Open.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<span class="c">/* Copy a file "file.bin" on the drive 1 to drive 0 */</span>
Open.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    f_mount(&amp;fs[1], "1:", 0);
Open.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    <span class="c">/* Open source file on the drive 1 */</span>
Open.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    fr = <em>f_open</em>(&amp;fsrc, "1:file.bin", FA_READ);
Open.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    f_mount(NULL, "1:", 0);
Opendir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_minimize">FF_FS_MINIMIZE</a> &lt;= 1</tt>.</p>
Param.c (f:\stm32f1-demo\librrary\param):    idex -= 1;
Param.c (f:\stm32f1-demo\librrary\param):            *idex = param_lenth + 1;
Param.c (f:\stm32f1-demo\librrary\param):    idex -= 1;
Param.h (f:\stm32f1-demo\librrary):#define	true 1
Param.h (f:\stm32f1-demo\librrary):    PARAM_TYPE_UINT8 = 1, /* 8-bit unsigned integer | */
Printf.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When the string was written successfuly, it returns number of character encoding units written to the file. When the function failed due to disk full or any error, an <tt>EOF (-1)</tt> will be returned.</p>
Printf.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dt>width</dt><dd>Minimum width of the field, <tt>1-99</tt> or <tt>*</tt>. If the width of generated string is less than the specified value, rest field is padded with white spaces or zeros. An <tt>*</tt> specifies the value comes from an argument in int type.</dd>
Printf.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When FatFs is configured for Unicode API (<tt><a href="config.html#lfn_unicode">FF_LFN_UNICODE</a> &gt;= 1</tt>), character encoding on the string fuctions, <tt>f_putc</tt>, <tt>f_puts</tt>, <tt>f_printf</tt> and <tt>f_gets</tt> function, is also switched to Unicode. The Unicode characters in multiple encoding unit, such as surrogate pair and multi-byte sequence, should not be divided into two function calls, or the character will be lost. The character encoding <em>on the file</em> to be written via this function is selected by <tt><a href="config.html#strf_encode">FF_STRF_ENCODE</a></tt> option. If the character encoding on the file differs from that on the API, it is converted in this function. In this case, input characters with wrong encoding or invalid for the output will be lost.</p>
Printf.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This is a wrapper function of <a href="write.html"><tt>f_write</tt></a> function. Available when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 0</tt> and <tt><a href="config.html#use_strfunc">FF_USE_STRFUNC</a> &gt;= 1</tt>. When it is set to 2, <tt>'\n'</tt>s contained in the output are converted to <tt>'\r'+'\n'</tt> each.</p>
Printf.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    <em>f_printf</em>(&amp;fil, "%u", -1);              <span class="c">/* "65535" or "4294967295" */</span>
Protocol.h (f:\stm32f1-demo\mavlink):    dst[0] = src[1];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[1] = src[0];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[1] = src[2];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[2] = src[1];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[1] = src[6];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[6] = src[1];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[1] = src[1];
Protocol.h (f:\stm32f1-demo\mavlink):    dst[1] = src[1];
Putc.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When the character was written successfuly, it returns number of character encoding units written to the file. When the function failed due to disk full or any error, an <tt>EOF (-1)</tt> will be returned.</p>
Putc.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When FatFs is configured for Unicode API (<tt>FF_LFN_UNICODE &gt;= 1</tt>), character encoding on the string fuctions, <tt>f_putc</tt>, <tt>f_puts</tt>, <tt>f_printf</tt> and <tt>f_gets</tt> function, is also switched to Unicode. The character encoding on the file to be written via those functions is selected by <tt>FF_STRF_ENCODE</tt> option. The Unicode characters in multiple encoding unit, such as surrogate pair and multi-byte sequence, cannot be written by this function.</p>
Putc.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This is a wrapper function of <a href="write.html"><tt>f_write</tt></a> function. Available when <tt>FF_FS_READONLY == 0</tt> and <tt>FF_USE_STRFUNC</tt> is 1 or 2. When it is set to 2, a <tt>'\n'</tt> is converted to <tt>'\r'+'\n'</tt>.</p>
Puts.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When the string was written successfuly, it returns number of character encoding units written to the file. When the function failed due to disk full or any error, an EOF (-1) will be returned.</p>
Puts.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>When FatFs is configured for Unicode API (<tt><a href="config.html#lfn_unicode">FF_LFN_UNICODE</a> &gt;= 1</tt>), character encoding on the string fuctions, <tt>f_putc</tt>, <tt>f_puts</tt>, <tt>f_printf</tt> and <tt>f_gets</tt> function, is also switched to Unicode. The input Unicode characters in multiple encoding unit, such as surrogate pair and multi-byte sequence, should not be divided into two function calls, or the character will be lost. The character encoding on the file to be written via this functions is selected by <tt><a href="config.html#strf_encode">FF_STRF_ENCODE</a></tt> option. If the character encoding on the file differs from that on the API, it is converted in this function. In this case, input characters with wrong encoding or invalid for the output will be lost.</p>
Puts.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>This is a wrapper function of <a href="write.html"><tt>f_write</tt></a> function. Available when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 0</tt> and <tt><a href="config.html#use_strfunc">FF_USE_STRFUNC</a></tt> is 1 or 2. When it is set to 2, <tt>'\n'</tt>s contained in the string are converted to <tt>'\r'+'\n'</tt>.</p>
Readdir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<li>The LFN contains any character not defined in current code page. (Not the case at <tt>FF_LFN_UNICODE &gt;= 1</tt>)</li>
Readdir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>There is a problem on reading a directory of exFAT volume. The exFAT does not support short file name. This means no name can be returned on the condition above. If it is the case, "?" is returned into the <tt>fname[]</tt> to indicate that the object is not accessible. To avoid this problem, configure FatFs <tt><a href="config.html#lfn_unicode">FF_LFN_UNICODE</a> &gt;= 1</tt> and <tt>FF_MAX_LFN == 255</tt> to support the full feature of LFN specification.</p>
Readdir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_minimize">FF_FS_MINIMIZE</a> &lt;= 1</tt>.</p>
Readdir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    res = f_mount(&amp;fs, "", 1);
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<link rel="Edit-Time-Data" href="Library_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>Release Notes for STM32F10x Standard Peripherals Library Drivers</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>STMicroelectronics</o:LastAuthor> <o:Revision>37</o:Revision> <o:TotalTime>136</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2009-03-01T17:56:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>522</o:Words> <o:Characters>2977</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>24</o:Lines> <o:Paragraphs>6</o:Paragraphs> <o:CharactersWithSpaces>3493</o:CharactersWithSpaces> <o:Version>11.6568</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:Zoom>110</w:Zoom> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):margin:1.0in 1.25in 1.0in 1.25in;
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):</style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0in 5.4pt 0in 5.4pt; mso-para-margin:0in; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]--><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="5122"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--></head>
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<td style="padding: 1.5pt;">
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<ol style="margin-top: 0cm;" start="1" type="1">
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):                  <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">1 new function to select the CAN operating mode: CAN_OperatingModeRequest().</span></li>
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):                  <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">1 new function to support CAN TT mode: CAN_TTComModeCmd().</span><span style="font-size: 10pt; font-family: Verdana;"><br>
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add 1 new function:</span></li>
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):            <ol style="margin-top: 0in;" start="1" type="1">
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):            <ol style="margin-top: 0in;" start="2" type="1">
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<ol style="margin-top: 0in;" start="1" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li></ol>
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<ol style="margin-top: 0in;" start="2" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Driver</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<ol style="margin-top: 0in;" start="1" type="1">
Release_Notes.html (f:\stm32f1-demo\stm32f10x_stdperiph_driver):<ol style="margin-top: 0in;" start="2" type="1">
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">    
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):    <link rel="Edit-Time-Data" href="Release_Notes%20%28package%29_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>Release Notes for STM32F10x, STM32L1xx and STM32F3xx USB-FS-Device Driver</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>STMicroelectronics</o:LastAuthor> <o:Revision>145</o:Revision> <o:TotalTime>461</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2010-12-13T14:14:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>358</o:Words> <o:Characters>2045</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>17</o:Lines> <o:Paragraphs>4</o:Paragraphs> <o:CharactersWithSpaces>2399</o:CharactersWithSpaces> <o:Version>11.9999</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:View>Normal</w:View> <w:SpellingState>Clean</w:SpellingState> <w:GrammarState>Clean</w:GrammarState> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:Compatibility> <w:UseFELayout/> </w:Compatibility> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->    
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	panose-1:2 4 5 3 5 4 6 3 2 4;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-font-charset:1;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	panose-1:2 15 5 2 2 2 4 3 2 4;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	panose-1:2 11 6 4 3 5 4 4 2 4;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	panose-1:2 11 6 4 3 5 4 4 2 4;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-style-link:"Heading 1 Char";
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-outline-level:1;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-style-name:"Heading 1 Char";
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-style-link:"Heading 1";
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	margin:1.0in 1.25in 1.0in 1.25in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.0in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      	{mso-level-tab-stop:1.5in;
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):      <o:idmap v:ext="edit" data="1"/>
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):                      <td style="padding: 1.5pt;">    
Release_Notes.html (f:\stm32f1-demo\stm32_usb-fs-device_driver):                        <ol style="margin-top: 0in;" start="1" type="1">     
Scsi_data.c (f:\stm32f1-demo\stm32_usb-driver\src):    0x80,          /* RMB = 1: Removable Medium */
Scsi_data.c (f:\stm32f1-demo\stm32_usb-driver\src):    0x00,          /* SCCS = 1: Storage Controller Component */
Scsi_data.c (f:\stm32f1-demo\stm32_usb-driver\src):    '1', '.', '0', ' '
Scsi_data.c (f:\stm32f1-demo\stm32_usb-driver\src):    0x80,          /* RMB = 1: Removable Medium */
Scsi_data.c (f:\stm32f1-demo\stm32_usb-driver\src):    0x00,          /* SCCS = 1: Storage Controller Component */
Scsi_data.c (f:\stm32f1-demo\stm32_usb-driver\src):    '1', '.', '0', ' '
Sdir.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    BYTE*   fn;         <span class="c">/* Pointer to the SFN buffer (in/out) {file[8],ext[3],status[1]} */</span>
Setcp.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<tr><td>850</td><td>Latin 1</td></tr>
Setcp.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>The <tt>f_setcp</tt> function sets the active code page for the path name. Also code conversion of string functions will be affected by the setting of code page when <tt><a href="config.html#lfn_unicode">FF_LFN_UNICODE</a> &gt;= 1</tt> and <tt><a href="config.html#strf_encode">FF_STRF_ENCODE</a> == 0</tt>. Because the initial setting of the code page is 0 and API function with extended character will not work properly, a valid code page needs to be set on the system start-up and it should not be changed on the fly.</p>
Setlabel.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 0</tt> and <tt><a href="config.html#use_label">FF_USE_LABEL</a> == 1</tt>.</p>
Sfatfs.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    BYTE    n_fats;       <span class="c">/* Number of FAT copies (1,2) */</span>
Sfileinfo.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    TCHAR   altname[FF_SFN_BUF + 1]; <span class="c">/* Alternative object name */</span>
Sfileinfo.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    TCHAR   fname[FF_LFN_BUF + 1];   <span class="c">/* Primary object name */</span>
Sfileinfo.html (f:\stm32f1-demo\librrary\fat32\documents\doc):    TCHAR   fname[12 + 1];       <span class="c">/* Object name */</span>
Sfileinfo.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Month (1..12)</dd>
Sfileinfo.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<dd>Day (1..31)</dd>
Sim7600.c (f:\stm32f1-demo\modules\sim7600):创建时间: 2018-1-05 by zam
Sim7600.c (f:\stm32f1-demo\modules\sim7600):创建时间: 2018-1-12 by zam
Sim7600.c (f:\stm32f1-demo\modules\sim7600):        return 1;
Sim7600.c (f:\stm32f1-demo\modules\sim7600):    while(1)
Sim7600.c (f:\stm32f1-demo\modules\sim7600):        return 1;
Sim7600.c (f:\stm32f1-demo\modules\sim7600):        return 1;
Sim7600.c (f:\stm32f1-demo\modules\sim7600):    if((ret = Sim_Net_cmd("AT+CGREG=1", "OK", 500)) != 0) //设置GPRS移动台类别为A,支持包交换和数据交换
Sim7600.c (f:\stm32f1-demo\modules\sim7600):    if((ret = Sim_Net_cmd("AT+CGDCONT=1,\"IP\",\"CMNET\"", "OK", 200)) != 0)
Sim7600.c (f:\stm32f1-demo\modules\sim7600):    if((ret = Sim_Net_cmd("AT+CSOCKSETPN=1", "OK", 200)) != 0)
Sim7600.c (f:\stm32f1-demo\modules\sim7600):    if((ret = Sim_Net_cmd("AT+CIPHEAD=1", "OK", 200)) != 0)
Sim7600.h (f:\stm32f1-demo\modules):#define HTTP_HOST_Get "GET /eflyCloud/gcs/getQianxunAccount HTTP/1.1\r\n            \
Sim7600.h (f:\stm32f1-demo\modules):#define HTTP_HOST_Free "GET /eflyCloud/gcs/getQianxunAccount?content={"appkey":510194} HTTP/1.1\r\n      \
Spi.c (f:\stm32f1-demo\drivers\spi):创建时间: 2018-1-05 by zam
Spi.c (f:\stm32f1-demo\drivers\spi):创建时间: 2018-1-05 by zam
Spi.c (f:\stm32f1-demo\drivers\spi):创建时间: 2018-1-05 by zam
Spi.h (f:\stm32f1-demo\drivers):#define TRUE 1
Stm3210b_eval.c (f:\stm32f1-demo\stm32_usb-driver\src):  * @version V5.0.1
Stm3210b_eval.h (f:\stm32f1-demo\stm32_usb-driver\inc):  * @version V5.0.1
Stm3210b_eval.h (f:\stm32f1-demo\stm32_usb-driver\inc):  LED2 = 1,
Stm3210b_eval.h (f:\stm32f1-demo\stm32_usb-driver\inc):  BUTTON_TAMPER = 1,
Stm3210b_eval.h (f:\stm32f1-demo\stm32_usb-driver\inc):  BUTTON_MODE_EXTI = 1
Stm3210b_eval.h (f:\stm32f1-demo\stm32_usb-driver\inc):  JOY_SEL = 1,
Stm3210b_eval.h (f:\stm32f1-demo\stm32_usb-driver\inc):  COM2 = 1
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):C Compiler:      Armcc.exe V5.05 update 1 (build 106)
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):Assembler:       Armasm.exe V5.05 update 1 (build 106)
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):Linker/Locator:  ArmLink.exe V5.05 update 1 (build 106)
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):Library Manager: ArmAr.exe V5.05 update 1 (build 106)
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):Hex Converter:   FromElf.exe V5.05 update 1 (build 106)
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):Dialog DLL:      DCM.DLL V1.13.1.0
STM32F1-DEMO.build_log.htm (f:\stm32f1-demo\prj\objects):..\LIBRRARY\messg_recive.h(45): warning:  #1-D: last line of file ends without a newline
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(.text)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> _printf_char_file.o(.text)
STM32F1-DEMO.htm (f:\stm32f1-demo\prj\objects):<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
Stm32f10x.h (f:\stm32f1-demo\core): #define __MPU_PRESENT             1 /*!< STM32 XL-density devices provide an MPU */
Stm32f10x.h (f:\stm32f1-demo\core):#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used */
Stm32f10x.h (f:\stm32f1-demo\core):  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                   */
Stm32f10x.h (f:\stm32f1-demo\core):  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt            */
Stm32f10x.h (f:\stm32f1-demo\core):  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                      */
Stm32f10x.h (f:\stm32f1-demo\core):  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
Stm32f10x.h (f:\stm32f1-demo\core):  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
Stm32f10x.h (f:\stm32f1-demo\core):  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
Stm32f10x.h (f:\stm32f1-demo\core):  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
Stm32f10x.h (f:\stm32f1-demo\core):#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)        /*!< ADCPRE[1:0] bits (ADC prescaler) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC 1 interface reset */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI 1 reset */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC 1 interface clock enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI 1 clock enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR2_PREDIV2_1                ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR2_PLL2MUL_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR2_PLL3MUL_1                ((uint32_t)0x00002000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE0                      ((uint32_t)0x00000003)        /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE1                      ((uint32_t)0x00000030)        /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE1_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE2                      ((uint32_t)0x00000300)        /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE2_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE3                      ((uint32_t)0x00003000)        /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE3_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE4                      ((uint32_t)0x00030000)        /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE4_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE5                      ((uint32_t)0x00300000)        /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE5_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE6                      ((uint32_t)0x03000000)        /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE6_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE7                      ((uint32_t)0x30000000)        /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_MODE7_1                    ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF0                       ((uint32_t)0x0000000C)        /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF0_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF1                       ((uint32_t)0x000000C0)        /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF1_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF2                       ((uint32_t)0x00000C00)        /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF2_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF3                       ((uint32_t)0x0000C000)        /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF3_1                     ((uint32_t)0x00008000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF4                       ((uint32_t)0x000C0000)        /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF4_1                     ((uint32_t)0x00080000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF5                       ((uint32_t)0x00C00000)        /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF5_1                     ((uint32_t)0x00800000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF6                       ((uint32_t)0x0C000000)        /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF6_1                     ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF7                       ((uint32_t)0xC0000000)        /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRL_CNF7_1                     ((uint32_t)0x80000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE8                      ((uint32_t)0x00000003)        /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE8_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE9                      ((uint32_t)0x00000030)        /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE9_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE10                     ((uint32_t)0x00000300)        /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE10_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE11                     ((uint32_t)0x00003000)        /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE11_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE12                     ((uint32_t)0x00030000)        /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE12_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE13                     ((uint32_t)0x00300000)        /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE13_1                   ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE14                     ((uint32_t)0x03000000)        /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE14_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE15                     ((uint32_t)0x30000000)        /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_MODE15_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF8                       ((uint32_t)0x0000000C)        /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF8_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF9                       ((uint32_t)0x000000C0)        /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF9_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF10                      ((uint32_t)0x00000C00)        /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF10_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF11                      ((uint32_t)0x0000C000)        /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF11_1                    ((uint32_t)0x00008000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF12                      ((uint32_t)0x000C0000)        /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF12_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF13                      ((uint32_t)0x00C00000)        /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF13_1                    ((uint32_t)0x00800000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF14                      ((uint32_t)0x0C000000)        /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF14_1                    ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF15                      ((uint32_t)0xC0000000)        /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  GPIO_CRH_CNF15_1                    ((uint32_t)0x80000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define GPIO_IDR_IDR1                        ((uint16_t)0x0002)            /*!< Port input data, bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define GPIO_ODR_ODR1                        ((uint16_t)0x0002)            /*!< Port output data, bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define GPIO_BSRR_BS1                        ((uint32_t)0x00000002)        /*!< Port x Set bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define GPIO_BSRR_BR1                        ((uint32_t)0x00020000)        /*!< Port x Reset bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define GPIO_BRR_BR1                         ((uint16_t)0x0002)            /*!< Port x Reset bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define GPIO_LCKR_LCK1                       ((uint32_t)0x00000002)        /*!< Port x Lock bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EVCR_PIN_1                      ((uint8_t)0x02)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EVCR_PIN_PX1                    ((uint8_t)0x01)               /*!< Pin 1 selected */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EVCR_PORT_1                     ((uint8_t)0x20)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_USART3_REMAP               ((uint32_t)0x00000030)        /*!< USART3_REMAP[1:0] bits (USART3 remapping) */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_USART3_REMAP_1             ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_TIM1_REMAP                 ((uint32_t)0x000000C0)        /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_TIM1_REMAP_1               ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_TIM2_REMAP                 ((uint32_t)0x00000300)        /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_TIM2_REMAP_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_TIM3_REMAP                 ((uint32_t)0x00000C00)        /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_TIM3_REMAP_1               ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_CAN_REMAP                  ((uint32_t)0x00006000)        /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_CAN_REMAP_1                ((uint32_t)0x00004000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((uint32_t)0x00020000)        /*!< ADC 1 External Trigger Injected Conversion remapping */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((uint32_t)0x00040000)        /*!< ADC 1 External Trigger Regular Conversion remapping */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_MAPR_SWJ_CFG_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core): #define AFIO_MAPR_TIM2ITR1_IREMAP            ((uint32_t)0x20000000)        /*!< TIM2ITR1_IREMAP bit (TIM2 internal trigger 1 remapping) */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1                   ((uint16_t)0x00F0)            /*!< EXTI 1 configuration */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PA                ((uint16_t)0x0000)            /*!< PA[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PB                ((uint16_t)0x0010)            /*!< PB[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PC                ((uint16_t)0x0020)            /*!< PC[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PD                ((uint16_t)0x0030)            /*!< PD[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PE                ((uint16_t)0x0040)            /*!< PE[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PF                ((uint16_t)0x0050)            /*!< PF[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define AFIO_EXTICR1_EXTI1_PG                ((uint16_t)0x0060)            /*!< PG[1] pin */
Stm32f10x.h (f:\stm32f1-demo\core):#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR7_PSIZE            ,         ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_CR1_DUALMOD_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CEC_OAR_OA_1             ((uint16_t)0x0002)     /*!<  Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!< CMS[1:0] bits (Center-aligned mode selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!< CKD[1:0] bits (clock division) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!< Output Idle state 1 (OC1 output) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!< Output Idle state 1 (OC1N output) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!< ETPS[1:0] bits (External trigger prescaler) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!< Capture/Compare 1 DMA request enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt Flag */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!< Capture/Compare 1 Overcapture Flag */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!< Capture/Compare 1 Generation */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!< CC1S[1:0] bits (Capture/Compare 1 Selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!< Output Compare 1 Fast enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!< Output Compare 1 Preload enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!< OC1M[2:0] bits (Output Compare 1 Mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!< CC2S[1:0] bits (Capture/Compare 2 Selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!< IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!< IC1F[3:0] bits (Input Capture 1 Filter) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!< IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!< CC3S[1:0] bits (Capture/Compare 3 Selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!< CC4S[1:0] bits (Capture/Compare 4 Selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!< IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!< IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!< Capture/Compare 1 output enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!< Capture/Compare 1 output Polarity */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!< Capture/Compare 1 Complementary output enable */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!< Capture/Compare 1 Complementary output Polarity */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 1 Value */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!< LOCK[1:0] bits (Lock Configuration) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[1:0] bits (ECC page size) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!< Abort Request for Mailbox 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!< Transmit Mailbox 1 Empty */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!< Lowest Priority Flag for Mailbox 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!< FIFO 1 Message Pending */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!< FIFO 1 Full */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!< FIFO 1 Overrun */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!< Release FIFO 1 Output Mailbox */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!< Time Segment 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!< Filter Init Mode bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!< Filter Scale Configuration bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!< Filter FIFO Assignment for Filter 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!< Filter 1 Active */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!< DATLEN[1:0] bits (Data length to be transferred) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!< I2SSTD[1:0] bits (I2S standard selection) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!< I2SCFG[1:0] bits (I2S configuration mode) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
Stm32f10x.h (f:\stm32f1-demo\core):#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):#define  FLASH_ACR_LATENCY_2                 ((uint8_t)0x02)               /*!< Bit 1 */
Stm32f10x.h (f:\stm32f1-demo\core):  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
Stm32f10x.h (f:\stm32f1-demo\core):   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
Stm32f10x.h (f:\stm32f1-demo\core):  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
Stm32f10x.h (f:\stm32f1-demo\core):  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
Stm32f10x.h (f:\stm32f1-demo\core):  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
Stm32f10x.h (f:\stm32f1-demo\core):  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
Stm32f10x.h (f:\stm32f1-demo\core):  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  ADC_InitStruct->ADC_NbrOfChannel = 1;
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *         count value. This number must be between 1 and 8.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  tmpreg2 = Number - 1;
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* For Rank 1 to 6 */
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Get JL value: Number = JL+1 */
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   This parameter must be a number between 1 to 4.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  tmpreg2 = Length - 1; 
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
Stm32f10x_adc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                               This parameter must range from 1 to 16. */
Stm32f10x_bkp.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   This parameter can be BKP_DRx where x:[1, 42]
Stm32f10x_bkp.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   This parameter can be BKP_DRx where x:[1, 42]
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:           where x can be 1 or 2 to to select the CAN 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    /* FIFO 1 assignation for the filter */
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  CAN_InitStruct->CAN_Prescaler = 1;
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    transmit_mailbox = 1;
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):                                             ((uint32_t)TxMessage->Data[1] << 8) | 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:            where x can be 1 or 2 to to select the 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral. 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral. 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:          where x can be 1 or 2 to to select the CAN peripheral.  
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *         by 1 or by 8 depending on the error condition as defined by the CAN 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *         decremented by 1 or reset to 120 if its value was higher than 128. 
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.  
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                 It ranges from 1 to 1024. */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                 Segment 1. This parameter can be a value of 
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
Stm32f10x_can.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
Stm32f10x_conf.h (f:\stm32f1-demo\core):/* #define USE_FULL_ASSERT    1 */
Stm32f10x_dac.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
Stm32f10x_dac.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *         x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
Stm32f10x_dma.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
Stm32f10x_exti.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */
Stm32f10x_flash.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src): STM32F10x_XL devices feature up to 1 Mbyte with dual bank architecture for read-while-write (RWW) capability:
Stm32f10x_flash.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
Stm32f10x_flash.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):  FLASH_BUSY = 1,
Stm32f10x_flash.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                                                   Write protection of page 0 to 1 */
Stm32f10x_flash.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                                  and this parameter is selected the device will boot from Bank 2 or Bank 1,
Stm32f10x_fsmc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
Stm32f10x_fsmc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
Stm32f10x_fsmc.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                             This parameter can be a value between 1 and 0xF.
Stm32f10x_gpio.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *                                        to TIM2 Internal Trigger 1 for calibration (only for Connectivity line devices)
Stm32f10x_gpio.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):  GPIO_Speed_10MHz = 1,
Stm32f10x_gpio.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */
Stm32f10x_gpio.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                                                 to TIM2 Internal Trigger 1 for calibration
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    I2Cx->TRISE = freqrange + 1; 
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Reset I2Cx Own address2 bit [7:1] */
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src): * 1) Basic state monitoring:
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src): *     by 16 bits and concatenated to Status Register 1).
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src): *  1) Basic state monitoring
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):  * 1) In normal case (only one address managed by the slave), when the address 
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* 1) Case of One Single Address managed by the slave */
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc): * 1) Basic state monitoring:
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc): *     by 16 bits and concatenated to Status Register 1).
Stm32f10x_i2c.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc): *  1) Basic state monitoring
Stm32f10x_it.c (f:\stm32f1-demo\core):  while (1)
Stm32f10x_it.c (f:\stm32f1-demo\core):  while (1)
Stm32f10x_it.c (f:\stm32f1-demo\core):  while (1)
Stm32f10x_it.c (f:\stm32f1-demo\core):  while (1)
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Clear SW[1:0] bits */
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Clear ADCPRE[1:0] bits */
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):        prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  if (tmp == 1)               /* The flag to check is in CR register */
Stm32f10x_rcc.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
Stm32f10x_sdio.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg SDIO_RESP1: Response Register 1
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):      packetlength = 1;
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Test if the divider is 1 or 0 or greater than 0xFF */
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  itmask = (uint16_t)1 << (uint16_t)itpos;
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_spi.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *   - 1, 2 or 3 in SPI mode 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src): /* Disable the Channel 1: Reset the CC1E Bit */
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 or 8 to select the TIM 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIM_TS_ITR1: Internal Trigger 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_TS_ITR1: Internal Trigger 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @brief  Forces the TIMx output 1 waveform to active or inactive level.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @brief  Configures the TIMx Output Compare 1 Fast feature.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @brief  Configures the TIMx channel 1 polarity.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_Channel_1: TIM Channel 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_Channel_1: TIM Channel 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_Channel_1: TIM Channel 1
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    tmp += (TIM_Channel>>1);
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @brief  Sets the TIMx Input Capture 1 prescaler.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select 
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @brief  Gets the TIMx Input Capture 1 value.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @retval Capture Compare 1 Register value.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Get the Capture 1 Register value */
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Disable the Channel 1: Reset the CC1E Bit */
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):                                       This means in PWM mode that (N+1) corresponds to:
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST1: TIM 1 and 8 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST2: TIM 1, 8, 15 16 and 17 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST3: TIM 1, 2, 3, 4, 5 and 8 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST4: TIM 1, 2, 3, 4, 5, 8, 15, 16 and 17 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST5: TIM 1, 2, 3, 4, 5, 8 and 15 */                                            
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST6: TIM 1, 2, 3, 4, 5, 8, 9, 12 and 15 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST7: TIM 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 and 15 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST8: TIM 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16 and 17 */                                        
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):/* LIST9: TIM 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, and 17 */
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
Stm32f10x_tim.h (f:\stm32f1-demo\stm32f10x_stdperiph_driver\inc):#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
Stm32f10x_usart.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
Stm32f10x_usart.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
Stm32f10x_usart.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
Stm32f10x_usart.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral. 
Stm32f10x_wwdg.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
Stm32f10x_wwdg.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Clear WDGTB[1:0] bits */
Stm32f10x_wwdg.c (f:\stm32f1-demo\stm32f10x_stdperiph_driver\src):  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):  *              1 - Apply the SD Card initialization process at 400KHz and check
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):  *          |      SDIO D2                |   D2          |    1        |
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):       or SD card 1.x */
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):            validvoltage = (((response >> 31) == 1) ? 1 : 0);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        CID_Tab[1] = SDIO_GetResponse(SDIO_RESP2);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        CSD_Tab[1] = SDIO_GetResponse(SDIO_RESP2);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    /*!< Byte 1 */
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)((CSD_Tab[1] & 0xFF000000) >> 24);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)((CSD_Tab[1] & 0x00FF0000) >> 16);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)((CSD_Tab[1] & 0x0000FF00) >> 8);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        cardinfo->SD_csd.DeviceSizeMul = (tmp & 0x03) << 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) * 512 * 1024;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    cardinfo->SD_csd.EraseGrMul = (tmp & 0x3F) << 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    cardinfo->SD_csd.CSD_CRC = (tmp & 0xFE) >> 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    cardinfo->SD_csd.Reserved4 = 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    /*!< Byte 1 */
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)((CID_Tab[1] & 0xFF000000) >> 24);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)((CID_Tab[1] & 0x00FF0000) >> 16);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)((CID_Tab[1] & 0x0000FF00) >> 8);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    tmp = (uint8_t)(CID_Tab[1] & 0x000000FF);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    cardinfo->SD_cid.CID_CRC = (tmp & 0xFE) >> 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    cardinfo->SD_cid.Reserved2 = 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):  *     @arg SDIO_BusWide_1b: 1-bit data transfer
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):  *     @arg SDIO_BusWide_1b: 1-bit data transfer
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    StopCondition = 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):                restwords = ((512 - bytestransferred) % 4 == 0) ? ((512 - bytestransferred) / 4) : ((512 -  bytestransferred) / 4 + 1);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    StopCondition = 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    if(((CSD_Tab[1] >> 20) & SD_CCCC_ERASE) == 0)
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    /*!< According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    if(StopCondition == 1)
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    TransferEnd = 1;
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        if((scr[1] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        /*!< If requested card supports 1 bit mode operation */
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        if((scr[1] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    *(pscr + 1) = ((tempscr[0] & SD_0TO7BITS) << 24) | ((tempscr[0] & SD_8TO15BITS) << 8) | ((tempscr[0] & SD_16TO23BITS) >> 8) | ((tempscr[0] & SD_24TO31BITS) >> 24);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    *(pscr) = ((tempscr[1] & SD_0TO7BITS) << 24) | ((tempscr[1] & SD_8TO15BITS) << 8) | ((tempscr[1] & SD_16TO23BITS) >> 8) | ((tempscr[1] & SD_24TO31BITS) >> 24);
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):    while(NumberOfBytes != 1)
Stm32_eval_sdio_sd.c (f:\stm32f1-demo\modules\sdio_sd):        NumberOfBytes >>= 1;
Stm32_eval_sdio_sd.h (f:\stm32f1-demo\modules):			SD_CMD_CRC_FAIL                    = (1), /*!< Command response received (but CRC check failed) */
Stm32_eval_sdio_sd.h (f:\stm32f1-demo\modules):			SD_TRANSFER_BUSY = 1,
Stm32_eval_sdio_sd.h (f:\stm32f1-demo\modules):			__IO uint8_t  TAAC;                 /*!< Data read access-time 1 */
Stm32_eval_sdio_sd.h (f:\stm32f1-demo\modules):			__IO uint8_t  Reserved4;            /*!< always 1*/
Stm32_eval_sdio_sd.h (f:\stm32f1-demo\modules):			__IO uint8_t  Reserved2;            /*!< always 1 */
Stm32_eval_sdio_sd.h (f:\stm32f1-demo\modules):		#define SD_CMD_SEND_OP_COND                        ((uint8_t)1)
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  *          | SD_SPI_CS_PIN           |   ChipSelect  |    1        |
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  /*!< Byte 1 */
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_csd->TAAC = CSD_Tab[1];
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_csd->Reserved4 = 1;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  /*!< Byte 1 */
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  SD_cid->Reserved2 = 1;
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
Stm32_eval_spi_sd.c (f:\stm32f1-demo\modules\spi_sd):  * @retval The SD status: Read data response xxx0<status>1
Stm32_eval_spi_sd.h (f:\stm32f1-demo\modules):			__IO uint8_t  TAAC;                 /*!< Data read access-time 1 */
Stm32_eval_spi_sd.h (f:\stm32f1-demo\modules):			__IO uint8_t  Reserved4;            /*!< always 1*/
Stm32_eval_spi_sd.h (f:\stm32f1-demo\modules):			__IO uint8_t  Reserved2;            /*!< always 1 */
Stm32_eval_spi_sd.h (f:\stm32f1-demo\modules):		#define SD_CMD_SEND_OP_COND           1   /*!< CMD1 = 0x41 */
System_stm32f10x.c (f:\stm32f1-demo\core):  * 1.  This file provides two functions and one global variable to be called from 
System_stm32f10x.c (f:\stm32f1-demo\core):   1. After each device reset the HSI is used as System clock source.
System_stm32f10x.c (f:\stm32f1-demo\core):__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
System_stm32f10x.c (f:\stm32f1-demo\core):        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
System_stm32f10x.c (f:\stm32f1-demo\core):       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
System_stm32f10x.c (f:\stm32f1-demo\core):          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
System_stm32f10x.c (f:\stm32f1-demo\core):        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
System_stm32f10x.c (f:\stm32f1-demo\core):        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
System_stm32f10x.c (f:\stm32f1-demo\core):          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
System_stm32f10x.c (f:\stm32f1-demo\core):    /* Flash 1 wait state */
System_stm32f10x.c (f:\stm32f1-demo\core):    /* Flash 1 wait state */
Tca62724.c (f:\stm32f1-demo\modules\tca62724): * 2018-1-16     Bernard      the first version
Tca62724.c (f:\stm32f1-demo\modules\tca62724):    unsigned char msg[1];
Tca62724.c (f:\stm32f1-demo\modules\tca62724):    msg[1] = RGB_SET_VALUE.GREEN_LED;
Tca62724.h (f:\stm32f1-demo\modules): * 2018-1-16     Bernard      the first version
Testsuite.h (f:\stm32f1-demo\mavlink\common):        5,{ 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91 },{ 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151 },{ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211 },{ 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },{ 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        5,72,139,{ 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        963497464,17443,151,{ 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        5,72,139,{ 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        17235,{ 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        5,72,{ 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2 },243,{ 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        5,72,{ 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62 }
Testsuite.h (f:\stm32f1-demo\mavlink\common):        17235,139,206,17,{ 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }
Updates.txt (f:\stm32f1-demo\librrary\fat32\documents):  Removed ASCII-only configuration, FF_CODE_PAGE = 1. Use FF_CODE_PAGE = 437 instead.
Updates.txt (f:\stm32f1-demo\librrary\fat32\documents):  Added f_getlabel() and f_setlabel(). (_USE_LABEL = 1)
Updates.txt (f:\stm32f1-demo\librrary\fat32\documents):R0.07 (April 1, 2009)
Updates.txt (f:\stm32f1-demo\librrary\fat32\documents):R0.06 (April 1, 2008)
Updates.txt (f:\stm32f1-demo\librrary\fat32\documents):R0.04a (April 1, 2007)
Usart.c (f:\stm32f1-demo\drivers\uart):#if 1
Usart.c (f:\stm32f1-demo\drivers\uart):创建时间: 2018-1-05 by zam
Usart.c (f:\stm32f1-demo\drivers\uart):创建时间: 2018-1-05 by zam
Usart.c (f:\stm32f1-demo\drivers\uart):创建时间: 2018-1-05 by zam
Usart.c (f:\stm32f1-demo\drivers\uart):                    statu = 1;
Usart.c (f:\stm32f1-demo\drivers\uart):                case 1:
Usart.c (f:\stm32f1-demo\drivers\uart):                    statu = 1;
Usart.c (f:\stm32f1-demo\drivers\uart):                case 1:
Usart.c (f:\stm32f1-demo\drivers\uart):                            statu=1;
Usart.c (f:\stm32f1-demo\drivers\uart):                        case 1:
Usart.c (f:\stm32f1-demo\drivers\uart):                    statu = 1;
Usart.c (f:\stm32f1-demo\drivers\uart):                case 1:
Usart.h (f:\stm32f1-demo\drivers):#define TRUE 1
Usart.h (f:\stm32f1-demo\drivers):    USART_StopBits_1,       /* 1 stopbit */                         \
Usart.h (f:\stm32f1-demo\drivers):    1                   /* sub interrupt */                                     \
Usart.h (f:\stm32f1-demo\drivers):    USART_StopBits_1,       /* 1 stopbit */                         \
Usart.h (f:\stm32f1-demo\drivers):    1                   /* sub interrupt */                                     \
Usart.h (f:\stm32f1-demo\drivers):    USART_StopBits_1,       /* 1 stopbit */                         \
Usart.h (f:\stm32f1-demo\drivers):    1                   /* sub interrupt */                                     \
Usart.h (f:\stm32f1-demo\drivers):    1,                          /* dma R */                                         \
Usart.h (f:\stm32f1-demo\drivers):    1,                  /* dma T */                                                 \
Usart.h (f:\stm32f1-demo\drivers):    USART_StopBits_1,       /* 1 stopbit */                         \
Usart.h (f:\stm32f1-demo\drivers):    USART_StopBits_1,       /* 1 stopbit */                         \
Usb_bot.c (f:\stm32f1-demo\stm32_usb-driver\src):    if ((CBW.bLUN > Max_Lun) || (CBW.bCBLength < 1) || (CBW.bCBLength > 16))
Usb_bot.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define BOT_DATA_OUT                  1       /* Data Out state */
Usb_bot.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define SEND_CSW_ENABLE               1
Usb_bot.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define DIR_OUT                       1
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):#define ValBit(VAR,Place)    (VAR & (1 << Place))
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):#define SetBit(VAR,Place)    (VAR |= (1 << Place))
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):#define ClrBit(VAR,Place)    (VAR &= ((1 << Place) ^ 255))
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Return         : Return 1 , if the request is invalid when "Length" is 0.
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):      SetBit(StatusInfo0, 1);
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):      ClrBit(StatusInfo0, 1);
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):  uint16_t offset = 1;
Usb_core.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):*                  - 1 if not.
Usb_core.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):  SETTING_UP,       /* 1 */
Usb_core.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):     if CopyData() returns -1, the calling routine should not proceed
Usb_def.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):  DEVICE_DESCRIPTOR = 1,
Usb_desc.c (f:\stm32f1-demo\stm32_usb-driver\src):    1,              /* index of string Manufacturer  */
Usb_desc.c (f:\stm32f1-demo\stm32_usb-driver\src):    0x01,   /* bNumInterfaces: 1 interface */
Usb_desc.c (f:\stm32f1-demo\stm32_usb-driver\src):    0x81,   /*Endpoint address (IN, address 1) */
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):        /* DIR = 1 */
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):        (*pEpInt_OUT[EPindex-1])();
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):        (*pEpInt_IN[EPindex-1])();
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):      (*pEpInt_OUT[EPindex-1])();
Usb_int.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):      (*pEpInt_IN[EPindex-1])();
Usb_mem.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
Usb_mem.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
Usb_prop.c (f:\stm32f1-demo\stm32_usb-driver\src):uint32_t Max_Lun = 1;
Usb_prop.c (f:\stm32f1-demo\stm32_usb-driver\src):    1
Usb_prop.c (f:\stm32f1-demo\stm32_usb-driver\src):  /* Initialize Endpoint 1 */
Usb_prop.c (f:\stm32f1-demo\stm32_usb-driver\src):    /* Initialize Endpoint 1 */
Usb_prop.c (f:\stm32f1-demo\stm32_usb-driver\src):    return USB_UNSUPPORT;/*in this application we have only 1 interfaces*/
Usb_prop.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define LUN_DATA_LENGTH            1
Usb_pwr.c (f:\stm32f1-demo\stm32_usb-driver\src):      remotewakeupon = 1;
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Description    : Set the addresses of the buffer 0 and 1.
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):*                  wBuf1Addr: new address of buffer 1.
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Description    : Set the Buffer 1 address.
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Description    : Set the Buffer 1 address.
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Description    : Returns the address of the Buffer 1.
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Return         : Address of the Buffer 1.
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Description    : Returns the number of data received in the buffer 1 of a double
Usb_regs.c (f:\stm32f1-demo\stm32_usb-fs-device_driver\src):* Return         : Endpoint Buffer 1 count.
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):#define ENDP1       ((uint8_t)1)
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):/* EP_TYPE[1:0] EndPoint TYPE */
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):/* STAT_TX[1:0] STATus for TX transfer */
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):/* STAT_RX[1:0] STATus for RX transfer */
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : sets the type in the endpoint register(bits EP_TYPE[1:0])
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : gets the type in the endpoint register(bits EP_TYPE[1:0]) 
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : sets the status for tx transfer (bits STAT_TX[1:0]).
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : sets the status for rx transfer (bits STAT_TX[1:0])
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : sets the status for rx & tx (bits STAT_TX[1:0] & STAT_RX[1:0])
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : gets the status for tx/rx transfer (bits STAT_TX[1:0]
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):*                  /STAT_RX[1:0])
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):#define _SetEPTxAddr(bEpNum,wAddr) (*_pEPTxAddr(bEpNum) = ((wAddr >> 1) << 1))
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):#define _SetEPRxAddr(bEpNum,wAddr) (*_pEPRxAddr(bEpNum) = ((wAddr >> 1) << 1))
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):    wNBlocks = wCount >> 1;\
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : Sets buffer 0/1 address in a double buffer endpoint.
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):*                : wBuf1Addr = buffer 1 address.
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : Gets buffer 0/1 address of a double buffer endpoint.
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : Gets buffer 0/1 address of a double buffer endpoint.
Usb_regs.h (f:\stm32f1-demo\stm32_usb-fs-device_driver\inc):* Description    : Gets buffer 0/1 rx/tx counter for double buffering.
Usb_scsi.c (f:\stm32f1-demo\stm32_usb-driver\src):  if (CBW.CB[1] & 0x01)/*Evpd is set*/
Usb_scsi.c (f:\stm32f1-demo\stm32_usb-driver\src):  ReadCapacity10_Data[0] = (uint8_t)((Mass_Block_Count[lun] - 1) >> 24);
Usb_scsi.c (f:\stm32f1-demo\stm32_usb-driver\src):  ReadCapacity10_Data[1] = (uint8_t)((Mass_Block_Count[lun] - 1) >> 16);
Usb_scsi.c (f:\stm32f1-demo\stm32_usb-driver\src):  ReadCapacity10_Data[2] = (uint8_t)((Mass_Block_Count[lun] - 1) >>  8);
Usb_scsi.c (f:\stm32f1-demo\stm32_usb-driver\src):  ReadCapacity10_Data[3] = (uint8_t)(Mass_Block_Count[lun] - 1);
Usb_scsi.c (f:\stm32f1-demo\stm32_usb-driver\src):  if ((CBW.dDataLength == 0) && !(CBW.CB[1] & BLKVFY))/* BLKVFY not set*/
Usb_scsi.h (f:\stm32f1-demo\stm32_usb-driver\inc):#define RECOVERED_ERROR		                    1
Utime.html (f:\stm32f1-demo\librrary\fat32\documents\doc):<p>Available when <tt><a href="config.html#fs_readonly">FF_FS_READONLY</a> == 0</tt> and <tt><a href="config.html#use_chmod">FF_USE_CHMOD</a> == 1</tt>.</p>
Version.h (f:\stm32f1-demo\mavlink\common):#define MAVLINK_WIRE_PROTOCOL_VERSION "1.0"
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp): * 2018-1-5     Bernard      the first version
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):                wifi_date_buf[wifi_recived_len + 1] = 0;
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):        return 1;
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):    while(1)
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):            return Wifi_Esp_Cmd("AT+CWMODE=1", "OK", 2500);
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):返回参数：0:连接成功 1:连接失败
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):        return 1;   //错误
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):返回参数：0:连接成功 1:连接失败
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):        return 1;   //错误
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):返回参数：0:连接成功 1:连接失败
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):    Wifi_Esp_Cmd("AT+CIPMODE=1", "OK", 500); //透传模式
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):        return 1;
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):        return 1;
Wifi_esp.c (f:\stm32f1-demo\modules\wifi_esp):创建时间: 2018-1-05 by zam
Wifi_esp.h (f:\stm32f1-demo\modules): * 2018-1-5     Bernard      the first version
Wifi_esp.h (f:\stm32f1-demo\modules):#define WIFI_OP_SMARTCNFIG "AT+CWSTARTSMART=1"      //打开smartconfig模式
